<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="steam.workshopManager">Steam 创意工坊管理 - Project N.E.K.O.</title>
    <!-- i18next 加载器（统一处理 CDN 加载和初始化） -->
    <script src="/static/i18n-i18next.js"></script>
    <script src="/static/common_dialogs.js"></script>
    <style>
        *:focus {
            outline: none !important;
            box-shadow: none !important;
        }
        html, body {
            min-height: 100vh; 
            margin: 0; 
            padding: 0; 
            background: #eee; 
            color: #222;
            font-family: 'Segoe UI', Arial, sans-serif;
            overflow-x: hidden;
        }

        /* 布局容器 */
        .layout-container {
            display: flex;
            gap: 20px;
            max-width: 1400px;
            margin: 20px auto;
            padding: 0 20px;
        }

        #sidebar {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 280px;
            width: 280px;
            padding: 15px;
            background: #fff;
            border-radius: 12px;
        }

        .main-content {
            flex: 1;
            background: #fff;
            border-radius: 12px;
            padding: 20px;
            min-width: 0;
            /* 防止flex子项溢出 */
            overflow: visible;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-label {
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        .control-select,
        .control-input {
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid #ddd;
            font-size: 14px;
            cursor: pointer;
            background: #fff;
            color: #333;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23d5f1ff' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
        }
        
        /* 标签样式 */
        #notes-tags-container, #character-card-tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 0;
            padding: 0;
            border: none;
            border-radius: 0;
            background-color: transparent;
            align-items: center;
        }
        
        .tag {
            display: inline-flex;
            align-items: center;
            background-color: #007bff;
            color: white;
            padding: 4px 8px;
            border-radius: 16px;
            font-size: 14px;
            font-weight: 500;
        }
        
        .tag-remove {
            background: none;
            border: none;
            color: white;
            font-size: 16px;
            font-weight: bold;
            padding: 0;
            margin-left: 4px;
            cursor: pointer;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }
        
        .tag-remove:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        
        #workshop-notes-input {
            flex: 1;
            border: none;
            background: transparent;
            outline: none;
            min-width: 200px;
            font-size: 14px;
            padding: 4px 0;
        }

        .control-input {
            cursor: text;
            padding-right: 15px;
            background-image: none;
        }

        textarea.control-input {
            min-height: 100px;
            resize: vertical;
            font-family: inherit;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* 角色卡布局样式 */
        .character-card-layout {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        
        /* 模型拖放区域样式 */
        .model-drop-area {
            border: 2px dashed #cccccc;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background-color: #f9f9f9;
            margin-bottom: 10px;
        }
        
        .model-drop-area:hover {
            border-color: #0078d4;
            background-color: #f0f7ff;
        }
        
        .model-drop-area.dragover {
            border-color: #0078d4;
            background-color: #e1f0ff;
            box-shadow: 0 0 10px rgba(0, 120, 212, 0.2);
        }
        
        .drop-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }
        
        .drop-area-content p {
            margin: 5px 0;
            color: #666;
        }
        
        .drop-hint {
            font-size: 12px;
            color: #999;
        }
        
        .character-card-inputs {
            flex: 1;
        }
        
        .character-card-preview {
            flex-basis: 400px;
            flex-shrink: 0;
            max-width: 100%;
            display: flex;
            flex-direction: column;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 20px;
            box-sizing: border-box;
        }
        
        /* Fluent Design风格的预览区域 */
        .character-card-preview h3 {
            margin: 15px 0 10px 0;
            font-size: 16px;
            font-weight: 500;
            color: #333;
        }
        
        /* 第一个标题没有顶部间距 */
        .character-card-preview h3:first-child {
            margin-top: 0;
        }
        
        /* Fluent Design风格的分割线 */
        .fluent-divider {
            height: 1px;
            background-color: #eaeaea;
            margin: 15px 0;
            border: none;
        }
        
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        
        .header-buttons {
            display: flex;
            gap: 10px;
        }
        
        .save-button-container {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #eaeaea;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .btn-large {
            width: 100%;
            padding: 12px 0;
            font-size: 16px;
        }
        
        /* 响应式设计 */
        @media (max-width: 900px) {
            .character-card-layout {
                flex-direction: column;
            }
            
            .character-card-preview {
                width: 100%;
            }
        }

        .control-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .checkbox-label {
            cursor: pointer;
            font-size: 14px;
            user-select: none;
        }

        .btn {
            padding: 10px 15px;
            border-radius: 8px;
            border: none;
            font-size: 14px;
            cursor: pointer;
            color: white;
            transition: background 0.2s, transform 0.2s, box-shadow 0.2s;
            text-align: center;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .btn:disabled {
            background: #e0e0e0;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .btn-primary {
            background-color: #0078d4;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background-color: #005a9e;
        }

        .btn-secondary {
            background: #d5f1ff;
            color: #333;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #b8e5ff;
            color: #333;
        }

        #sidebar .btn-secondary.active {
            background: #44b7fe;
            color: white;
        }

        .btn-success {
            background: #44b7fe;
        }

        .btn-success:hover:not(:disabled) {
            background: #2662c8;
        }

        .btn-danger {
            background: #ff6b6b;
        }

        .btn-danger:hover:not(:disabled) {
            background: #ff4757;
        }

        .btn-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .btn-icon img {
            width: 16px;
            height: 16px;
            object-fit: contain;
        }

        .action-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .action-group .control-select,
        .action-group .control-input {
            flex-grow: 1;
        }

        h1 {
            color: #333;
            margin-bottom: 25px;
            font-weight: 600;
            font-size: 24px;
            display: flex;
            align-items: center;
            gap: 10px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }

        /* 上传区域样式 - 去掉边框效果 */
        .upload-section {
            background: #fff;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
        }

        .upload-section h2 {
            color: #333;
            font-weight: 600;
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 20px;
        }

        /* 标签容器样式 */
        .tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }

        .tag {
            background: #d5f1ff;
            color: #333;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: background 0.2s;
        }

        .tag:hover {
            background: #b8e5ff;
        }

        .tag-remove {
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            line-height: 1;
        }

        /* 信息框样式 */
        .info-box {
            background: #e1f5fe;
            border-left: 4px solid #0288d1;
            padding: 16px 20px;
            margin: 16px 0;
            border-radius: 8px;
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .info-box p {
            margin: 0;
            color: #01579b;
            font-weight: 500;
        }

        /* 状态指示器 */
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        /* 标签页导航样式 */
        .navigation-tabs {
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            margin-bottom: 20px;
            overflow: hidden;
        }

        .tab-buttons {
            display: flex;
            padding: 5px;
            background: #f5f5f5;
        }

        .tab-button {
            flex: 1;
            padding: 12px 20px;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 15px;
            font-weight: 500;
            color: #666;
            border-radius: 8px;
            transition: all 0.3s ease;
            margin: 0 2px;
        }

        .tab-button:hover {
            background: #e0e0e0;
            color: #333;
        }

        .tab-button.active {
            background: #44b7fe;
            color: white;
        }

        .tab-content {
            padding: 20px;
            background: #fff;
            border-radius: 0 0 12px 12px;
            overflow: visible;
        }
        
        .tab-contents {
            width: 100%;
        }

        /* 菜单部分样式 */
        .menu-section h3,
        .config-section h4 {
            margin-top: 20px;
            margin-bottom: 12px;
            font-size: 16px;
            font-weight: 600;
            color: #333;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 8px;
        }

        .menu-section .button-group {
            margin-bottom: 5px;
        }

        #sidebar .btn-secondary {
            margin-bottom: 2px;
        }

        .menu-section {
            margin-bottom: 5px;
        }

        .info-text {
            font-size: 12px;
            color: #666;
            margin: 5px 0;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .info-text p {
            margin: 0;
            line-height: 1.4;
        }

        /* 配置区域样式 - 去掉边框效果 */
        .section-card {
            background: #fff;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid #e0e0e0;
        }

        /* 区域标题样式 */
        .section-header {
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #f0f0f0;
        }

        .section-header h2 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
            color: #333;
        }

        .config-section {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .config-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 18px;
            font-weight: 600;
            color: #333;
        }

        .control-group {
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-label {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 4px;
            color: #333;
        }

        .control-input {
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            width: 100%;
            box-sizing: border-box;
        }

        .control-input:focus {
            outline: none;
            border-color: #44b7fe;
            box-shadow: 0 0 0 2px rgba(68, 183, 254, 0.2);
        }

        .control-group.checkbox {
            flex-direction: row;
            align-items: flex-start;
            gap: 10px;
        }

        .checkbox-label {
            font-size: 14px;
            font-weight: 500;
            color: #333;
            flex: 1;
        }

        .help-text {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
        }

        .help-text.success {
            color: #2e7d32;
        }

        .button-group {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 15px;
        }

        .action-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .action-group .control-input {
            flex: 1;
        }

        .action-group .btn {
            flex-shrink: 0;
            white-space: nowrap;
        }

        /* 响应式调整 */
        @media (max-width: 768px) {
            .button-group {
                flex-direction: column;
                align-items: stretch;
            }

            .control-group.checkbox {
                flex-direction: column;
                align-items: flex-start;
            }
        }

        /* 设置面板相关样式 */
        .settings-container {
            margin-top: 15px;
        }

        #settings-panel {
            border: 1px solid #ddd;
            border-radius: 10px;
            padding: 20px;
            margin-top: 15px;
            background-color: #fff;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.4s ease;
            overflow: hidden;
        }

        #settings-panel h3 {
            margin-top: 0;
            color: #333;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }

        .status-published {
            background-color: #2ecc71;
        }

        .status-pending {
            background-color: #f39c12;
        }

        .status-failed {
            background-color: #e74c3c;
        }

        /* 过滤器控件 */
        .filter-controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
            background: #fff;
            border-radius: 12px;
            padding: 15px 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .filter-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .filter-label {
            font-size: 14px;
            font-weight: 500;
            color: #333;
            white-space: nowrap;
            text-align: right;
            padding-right: 5px;
            min-width: 40px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
        }
        
        /* 卡片容器样式 - Fluent Design 风格 */
        .cards-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 24px;
            margin-top: 24px;
            padding: 12px 0;
        }

        /* 角色卡列表特定样式 - 最多显示两行，超出部分竖向滚动 */
        #character-cards-list.cards-container {
            /* 计算高度：2行卡片(220px*2) + 1行间距(24px) + 内边距(16px*2) = 504px */
            max-height: 504px;
            overflow-y: auto;
            overflow-x: visible;
            /* 添加左右内边距，避免卡片阴影被截断 */
            padding: 12px 16px;
            /* 添加滚动条样式 */
            scrollbar-width: thin;
            scrollbar-color: rgba(155, 155, 155, 0.5) transparent;
        }

        /* 滚动条样式 - WebKit浏览器 */
        #character-cards-list.cards-container::-webkit-scrollbar {
            width: 8px;
        }

        #character-cards-list.cards-container::-webkit-scrollbar-track {
            background: transparent;
        }

        #character-cards-list.cards-container::-webkit-scrollbar-thumb {
            background-color: rgba(155, 155, 155, 0.5);
            border-radius: 4px;
        }

        #character-cards-list.cards-container::-webkit-scrollbar-thumb:hover {
            background-color: rgba(155, 155, 155, 0.7);
        }
        
        /* Fluent Design 卡片基础样式 */
        .card, .workshop-card {
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08), 0 1px 2px rgba(0, 0, 0, 0.06);
            border: 1px solid rgba(0, 0, 0, 0.08);
            overflow: hidden;
            transition: all 0.25s cubic-bezier(0.2, 0, 0.13, 1.5);
            display: flex;
            flex-direction: column;
            height: auto;
            min-height: 220px;
            position: relative;
            cursor: pointer;
        }
        
        /* Fluent Design 卡片悬停效果 */
        .card:hover, .workshop-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.15), 0 4px 16px rgba(0, 0, 0, 0.1);
            border-color: rgba(0, 0, 0, 0.12);
        }
        
        /* 卡片头部样式 */
        .card-header {
            padding: 16px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.04);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 1), rgba(254, 254, 254, 1));
        }
        
        .card-header h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: rgba(0, 0, 0, 0.9);
            line-height: 1.5;
        }
        
        /* 卡片内容样式 */
        .card-content {
            padding: 16px;
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        /* 卡片图片样式 */
        .card-image {
            width: 100%;
            height: 180px;
            object-fit: cover;
            display: block;
            background-color: #f8f9fa;
            border-bottom: 1px solid rgba(0, 0, 0, 0.04);
        }
        
        /* 卡片文本样式 */
        .card-content p {
            margin: 0;
            font-size: 14px;
            line-height: 1.6;
            color: rgba(0, 0, 0, 0.6);
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
        }
        
        /* 标签容器样式 */
        .tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: auto;
            padding-top: 8px;
        }
        
        /* 标签样式 */
        .tag {
            background-color: rgba(0, 120, 212, 0.1);
            color: #0078d4;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 400;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            transition: background-color 0.2s ease;
        }
        
        .tag:hover {
            background-color: rgba(0, 120, 212, 0.15);
        }
        
        /* 标签移除按钮 */
        .tag-remove {
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            transition: background-color 0.2s ease;
        }
        
        .tag-remove:hover {
            background-color: rgba(0, 120, 212, 0.2);
        }
        
        /* Fluent Design 按钮样式已合并到.btn-primary类中 */
        
        /* Fluent Design 卡片标题样式 */
        .card-title {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: rgba(0, 0, 0, 0.9);
            line-height: 1.5;
        }
        
        /* Fluent Design 卡片描述样式 */
        .card-description {
            margin: 0;
            font-size: 14px;
            line-height: 1.6;
            color: rgba(0, 0, 0, 0.6);
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
        }
        
        /* Fluent Design 加载状态样式 */
        .loading-state {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 40px;
            color: rgba(0, 0, 0, 0.6);
            font-size: 14px;
        }
        
        /* Fluent Design 空状态样式 */
        .empty-state {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px;
            gap: 12px;
            color: rgba(0, 0, 0, 0.6);
            font-size: 14px;
        }
        
        /* Fluent Design 卡片深度效果 */
        .fluent-card {
            position: relative;
            overflow: hidden;
        }
        
        .fluent-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(to right, transparent, rgba(0, 0, 0, 0.1), transparent);
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .fluent-card:hover::before {
            opacity: 1;
        }




        
        .card-title {
            font-size: 18px;
            font-weight: 600;
            margin: 0 0 12px 0;
            color: #333;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        /* 删除重复的status-badge定义，只保留下方的统一样式 */

        .status-subscribed {
            background-color: #e6f3ff;
            color: #0066cc;
        }

        .status-downloading {
            background-color: #fff2cc;
            color: #cc7700;
        }

        .status-needs-update {
            background-color: #fff2cc;
            color: #cc7700;
        }

        .status-installed {
            background-color: #e6ffe6;
            color: #008000;
        }

        .author-info {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .author-avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: #0078d4;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
        }

        .card-info {
            font-size: 13px;
            color: #888;
            margin-bottom: 8px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        /* 统一的状态徽章样式 */
        .status-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 16px;
            font-size: 0.85em;
            font-weight: 500;
            margin-right: 8px;
            margin-bottom: 8px;
            background: #f0f0f0;
            color: #666;
            text-align: center;
            box-sizing: border-box;
        }

        /* 为卡片头部的状态徽章添加定位样式 */
        .card-header .status-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            margin: 0;
            z-index: 10;
            padding: 2px 8px;
            font-size: 11px;
            border-radius: 12px;
        }

        /* 调整卡片高度以适应新结构 */
        .workshop-card {
            background: #fff;
            border-radius: 16px;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.08);
            overflow: hidden;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            height: auto;
            min-height: 380px;
        }

        /* 卡片头部样式 */
        .card-header {
            position: relative;
            overflow: hidden;
        }

        /* 卡片信息网格布局 */
        .card-info-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 8px;
        }

        .card-info-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .info-label, .card-info-label {
            font-size: 12px;
            color: #888;
            font-weight: 500;
        }
        
        .card-info-item span:not(.info-label):not(.card-info-label) {
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }
        
        .info-value {
            font-size: 14px;
            color: #333;
            font-weight: 400;
        }

        .status-subscribed {
            background: #e3f2fd;
            color: #1565c0;
        }

        .status-installed {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .status-downloading {
            background: #fff3e0;
            color: #ef6c00;
            animation: pulse 2s infinite;
        }

        .status-needs-update {
            background: #fff8e1;
            color: #ff8f00;
        }

        .status-error {
            background: #ffebee;
            color: #c62828;
        }

        @keyframes pulse {
            0% {
                opacity: 0.7;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.7;
            }
        }

        /* 安装路径样式 */
        .card-path {
            background: #f5f7fa;
            padding: 10px 14px;
            border-radius: 10px;
            margin-bottom: 12px;
            overflow: hidden;
        }

        .path-text {
            font-size: 12px;
            color: #666;
            word-break: break-all;
            display: inline-block;
            max-width: 100%;
            line-height: 1.4;
        }

        /* 卡片操作按钮 */
        .card-actions {
            margin-top: auto;
            padding-top: 12px;
            display: flex;
            gap: 8px;
        }

        .card-actions button,
        .card-actions .button {
            width: 100%;
            padding: 11px 16px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: all 0.2s ease;
            text-align: center;
            display: inline-block;
        }

        .card-actions button:hover,
        .card-actions .button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.12);
        }

        /* 默认按钮样式 */
        .card-actions button,
        .card-actions .button {
            background: #f1f5f9;
            color: #334155;
            border: 1px solid #e2e8f0;
        }

        .card-actions button:hover,
        .card-actions .button:hover {
            background: #e2e8f0;
            border-color: #cbd5e1;
        }

        /* 主要按钮样式 */
        .card-actions .button-primary {
            background: #44b7fe;
            color: white;
            border: 1px solid #44b7fe;
        }

        .card-actions .button-primary:hover {
            background: #2662c8;
            border-color: #2662c8;
        }

        /* 禁用按钮样式 */
        .card-actions .button-disabled {
            background: #f1f5f9;
            color: #94a3b8;
            border: 1px solid #e2e8f0;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .card-actions .button-disabled:hover {
            transform: none;
            box-shadow: none;
            background: #f1f5f9;
            border-color: #e2e8f0;
        }

        /* 危险操作按钮样式 */
        .card-actions .button-danger {
            background: #e11d48;
            color: white;
            border: 1px solid #e11d48;
        }

        .card-actions .button-danger:hover {
            background: #be123c;
            border-color: #be123c;
        }

        /* 下载进度条样式 */
        .download-progress {
            margin: 12px 0 8px 0;
            width: 100%;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: #f0f0f0;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #0078d4, #44b7fe);
            display: flex;
            align-items: center;
            justify-content: flex-end;
            color: #333;
            font-size: 0.75em;
            font-weight: bold;
            transition: width 0.3s ease;
            padding-right: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) inset;
        }

        /* 空状态样式 */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #888;
        }

        .empty-state p {
            font-size: 16px;
            margin-bottom: 20px;
        }

        /* 分页控件样式 */
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 30px;
            gap: 12px;
        }

        .pagination .btn {
            min-width: 80px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 12px;
        }

        .pagination span {
            display: flex;
            align-items: center;
            height: 36px;
            min-width: 120px;
            text-align: center;
            padding: 0 8px;
        }

        /* 消息提示样式 */
        .success-message,
        .error-message,
        .warning-message {
            padding: 12px 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            position: relative;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transform: translateY(-10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .success-message {
            background: #e8f5e9;
            color: #2e7d32;
            border-left: 4px solid #4caf50;
        }

        .error-message {
            background: #ffebee;
            color: #c62828;
            border-left: 4px solid #f44336;
        }

        .warning-message {
            background: #fff8e1;
            color: #ff8f00;
            border-left: 4px solid #ffb74d;
        }

        .message-close {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            font-weight: bold;
            font-size: 18px;
            color: inherit;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .message-close:hover {
            opacity: 1;
        }

        /* 模态框样式 */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }

        .modal-content {
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            width: 100%;
            max-width: 800px;
            max-height: 85vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            animation: modalFadeIn 0.3s ease-out;
        }

        @keyframes modalFadeIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid #e0e0e0;
            background: #fafafa;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            color: #333;
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            color: #888;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            transition: background 0.2s, color 0.2s;
        }

        .modal-close:hover {
            background: #f0f0f0;
            color: #333;
        }

        .modal-body {
            padding: 8px;
            overflow-y: auto;
            flex: 1;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            padding: 10px 15px;
            border-top: 1px solid #e0e0e0;
            background: #fafafa;
            gap: 8px;
        }

        .item-detail-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 16px;
            padding: 20px;
            background: #fff;
        }

        .item-preview-large {
            width: 100%;
            max-height: 350px;
            object-fit: cover;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        /* 角色卡详情模态框样式 - 使用与物品详情一致的Fluent Design风格 */
        .character-card-detail-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .character-card-detail-name {
            font-size: 20px;
            font-weight: 600;
            color: #333;
            margin: 0 0 12px 0;
        }

        .character-card-detail-description {
            font-size: 14px;
            line-height: 1.5;
            margin: 0 0 20px 0;
            color: #666;
        }

        .character-card-detail-section {
            margin-bottom: 20px;
        }

        .character-card-detail-section h4 {
            font-size: 16px;
            font-weight: 600;
            margin: 0 0 12px 0;
            color: #333;
        }

        .character-card-detail-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
        }

        .character-card-detail-tags .tag {
            background-color: #f0f0f0;
            color: #333;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 13px;
        }

        .character-card-detail-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin-top: 8px;
        }

        .character-card-detail-info-item {
            font-size: 14px;
            display: flex;
            justify-content: space-between;
        }

        .character-card-detail-info-label {
            font-weight: 500;
            color: #666;
        }

        .character-card-detail-notes {
            background-color: #f5f5f5;
            padding: 12px;
            border-radius: 6px;
            margin-top: 8px;
            font-size: 14px;
            color: #666;
        }

        .character-card-detail-live2d-preview {
            width: 100%;
            height: 350px;
            background-color: #f5f5f5;
            border-radius: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 8px;
            font-size: 14px;
            color: #999;
            border: 2px dashed #d1d5db;
        }

        .character-card-detail-live2d-preview p {
            color: #6b7280;
            font-size: 16px;
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
            .character-card-detail-header {
                flex-direction: column;
            }

            .character-card-detail-live2d-preview {
                height: 300px;
            }
        }
        
        .item-info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 20px;
        }

        .item-info-item {
            margin: 0;
        }

        .item-info-label {
            font-weight: 600;
            color: #334155;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 4px;
        }

        .item-description {
            margin-top: 20px;
            line-height: 1.7;
            color: #475569;
            padding: 16px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #f1f5f9;
        }

        /* 浏览器通知样式 */
        .workshop-integration-info {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .workshop-integration-info h4 {
            color: #334155;
            margin: 0 0 12px 0;
            font-size: 16px;
            font-weight: 600;
        }

        .workshop-integration-info .info-text {
            font-size: 14px;
            color: #64748b;
        }

        .workshop-integration-info .info-text p {
            margin: 6px 0;
            line-height: 1.5;
        }

        /* 响应式调整 */
        @media (max-width: 1024px) {
            .layout-container {
                flex-direction: column;
                margin: 10px;
                padding: 0;
            }

            #sidebar {
                width: auto;
                min-width: auto;
            }

            .cards-container {
                grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            }
        }

        @media (max-width: 768px) {
            .filter-controls {
                flex-direction: column;
                align-items: stretch;
                gap: 15px;
            }

            .filter-group {
                flex-direction: column;
                align-items: stretch;
            }

            .item-info-grid {
                grid-template-columns: 1fr;
            }

            .modal-footer {
                flex-direction: column-reverse;
            }

            .modal-footer .btn {
                width: 100%;
            }
            
            .cards-container {
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            }
        }
        
        /* 极端窄屏幕适配 */
        @media (max-width: 200px) {
            .cards-container {
                grid-template-columns: 1fr;
            }
        }

        /* 水平标签页样式 */
        .tabs {
            display: flex;
            flex-wrap: nowrap;
            border-radius: 8px;
            background: #f0f4f8;
            padding: 2px;
            margin-bottom: 15px;
            justify-content: space-between;
        }

        .tab {
            padding: 10px 20px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #666;
            border-radius: 6px;
            transition: all 0.3s ease;
            text-align: center;
            white-space: nowrap;
            /* 响应式宽度设置 */
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* 媒体查询 - 当窗口宽度小于特定尺寸时调整标签样式 */
        @media (max-width: 600px) {
            .tab {
                flex: none;
                width: auto;
                min-width: 90px;
                padding: 10px 15px;
                font-size: 13px;
            }

            .tabs {
                justify-content: flex-start;
            }
        }

        /* 小窗口特定样式类 */
        .tabs.compact .tab {
            flex: 1;
            width: auto;
            padding: 10px 15px;
            text-align: center;
        }

        .tabs.compact {
            justify-content: flex-start;
            gap: 4px;
            /* 自适应左侧菜单宽度 */
            width: 100%;
        }

        /* 恢复大窗口样式的类 */
        .tabs.normal .tab {
            flex: 1;
            min-width: 0;
            padding: 10px 20px;
        }

        .tabs.normal {
            justify-content: space-between;
        }

        .tab:hover {
            background: #e1e8ed;
            color: #333;
        }

        .tab.active {
            background: #44b7fe;
            color: white;
            box-shadow: 0 2px 4px rgba(68, 183, 254, 0.3);
        }

        /* 页面控制按钮 */
        .page-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
        }

        /* 状态文本样式 */
        #status {
            color: #4f8cff;
            font-size: 14px;
            font-weight: 500;
            margin-top: 10px;
        }
    </style>
</head>

<body>
    <!-- 侧边栏 -->
    <!-- 布局容器 -->
    <div class="layout-container">
        <!-- 侧边栏 -->
        <div id="sidebar">
            <!-- 主要操作组 -->
            <div class="menu-section">
                <!-- 标签切换按钮组 -->
                <div class="tabs compact" id="workshop-tabs">
                     <button class="tab active" onclick="switchTab('subscriptions-content', event)" data-i18n="steam.subscriptions">订阅内容</button>
                     <button class="tab" onclick="switchTab('character-cards-content', event)" data-i18n="steam.characterCards">角色卡</button>
                  </div>
                
                <!-- 修复的自定义tooltip实现 -->
                <style>
                    /* 确保侧边栏作为定位容器 */
                    #sidebar {
                        position: relative;
                        overflow: visible;
                    }

                    /* 标签按钮基础样式 */
                    .tabs button {
                        position: relative;
                        cursor: pointer;
                        /* 禁用浏览器默认tooltip */
                        overflow: hidden;
                        text-overflow: ellipsis;
                    }

                    /* 移除可能存在的title属性 */
                    .tabs button {
                        title: "";
                    }

                    /* 完全重写的tooltip实现 */
                    .tabs button:hover {
                        /* 移除默认的title提示行为 */
                        pointer-events: auto;
                    }

                    /* 添加安全的工具提示实现 */
                    .tabs {
                        position: relative;
                        /* 确保tooltip在容器内 */
                        contain: layout;
                    }

                    /* 替代方案：通过JavaScript控制tooltip，完全避免CSS定位问题 */
                </style>

                <script>
                    // JavaScript控制的tooltip实现
                    document.addEventListener('DOMContentLoaded', function () {
                        const tabButtons = document.querySelectorAll('.tabs button');

                        // 创建tooltip元素
                        let tooltip = document.createElement('div');
                        tooltip.id = 'custom-tooltip';
                        tooltip.style.cssText = `
                        position: absolute;
                        background: rgba(0, 0, 0, 0.8);
                        color: white;
                        padding: 5px 10px;
                        border-radius: 4px;
                        font-size: 12px;
                        white-space: nowrap;
                        pointer-events: none;
                        z-index: 1000;
                        display: none;
                    `;
                        document.body.appendChild(tooltip);

                        // 为每个标签按钮添加事件监听
                        tabButtons.forEach(button => {
                            // 获取按钮文本作为tooltip内容
                            const tooltipText = button.textContent.trim();

                            button.addEventListener('mouseenter', function (e) {
                                // 计算tooltip位置
                                const buttonRect = button.getBoundingClientRect();
                                const sidebarRect = document.getElementById('sidebar').getBoundingClientRect();

                                // 计算tooltip尺寸
                                tooltip.textContent = tooltipText;
                                tooltip.style.display = 'block';
                                const tooltipRect = tooltip.getBoundingClientRect();

                                // 确保tooltip在侧边栏内显示
                                let left = buttonRect.left + buttonRect.width / 2 - tooltipRect.width / 2;

                                // 检查并修正左侧位置
                                if (left < sidebarRect.left + 10) {
                                    left = sidebarRect.left + 10;
                                }
                                // 检查并修正右侧位置
                                if (left + tooltipRect.width > sidebarRect.right - 10) {
                                    left = sidebarRect.right - tooltipRect.width - 10;
                                }

                                // 设置tooltip位置
                                tooltip.style.left = left + 'px';
                                tooltip.style.top = (buttonRect.top - tooltipRect.height - 5) + 'px';
                            });

                            button.addEventListener('mouseleave', function () {
                                tooltip.style.display = 'none';
                            });

                            // 阻止默认的title提示
                            button.addEventListener('mouseover', function (e) {
                                e.preventDefault();
                            });
                        });
                    });
                </script>
                <script>
                    // 响应式标签页处理
                    function updateTabsLayout() {
                        const tabs = document.getElementById('workshop-tabs');
                        const containerWidth = tabs.parentElement.clientWidth;

                        // 定义切换阈值
                        const thresholdWidth = 400;

                        if (containerWidth < thresholdWidth) {
                            tabs.classList.remove('normal');
                            tabs.classList.add('compact');
                        } else {
                            tabs.classList.remove('compact');
                            tabs.classList.add('normal');
                        }
                    }

                    // 初始化时调用一次
                    window.addEventListener('DOMContentLoaded', updateTabsLayout);
                    // 监听窗口大小变化
                    window.addEventListener('resize', updateTabsLayout);
                </script>
            </div>



            <!-- 关于创意工坊集成说明 -->
            <div class="menu-section workshop-integration-info">
                <div class="info-text">
                    <p data-i18n="steam.pageDescription">通过此页面，您可以浏览、订阅、下载和管理Steam创意工坊中的Live2D模型和声音。</p>
                    <p data-i18n="steam.voiceNote">如有语音音色请前往live2d设置页面手动注册</p>
                </div>
            </div>


        </div>

        <!-- 主内容区域 -->
        <div class="main-content">
        <!-- 标题已移除 -->
        
        <!-- 标签内容容器 -->
        <div class="tab-contents">
            <!-- 订阅内容标签页 -->
            <div id="subscriptions-content" class="tab-content active">
                <div class="section-card">
                    <div class="section-header">
                         <h2 data-i18n="steam.mySubscriptions">我的订阅物品</h2>
                      </div>
                    
                    <div class="filter-controls">
                    <div class="filter-group">
                         <div class="filter-label" data-i18n="steam.search">搜索：</div>
                         <input type="text" id="search-subscription" class="control-input" placeholder="" onkeyup="filterSubscriptions(this.value)" data-i18n-placeholder="steam.searchPlaceholder">
                      </div>
                    <div class="filter-group">
                         <div class="filter-label" data-i18n="steam.sort.title">排序：</div>
                        <select id="sort-subscription" class="control-select" onchange="applySort(this.value)">
                            <option value="name_asc" data-i18n="steam.sort.nameAsc">名称（升序）</option>
                            <option value="name_desc" data-i18n="steam.sort.nameDesc">名称（降序）</option>
                            <option value="date_asc" data-i18n="steam.sort.dateAsc">订阅日期（升序）</option>
                            <option value="date_desc" data-i18n="steam.sort.dateDesc">订阅日期（降序）</option>
                            <option value="size_asc" data-i18n="steam.sort.sizeAsc">文件大小（升序）</option>
                            <option value="size_desc" data-i18n="steam.sort.sizeDesc">文件大小（降序）</option>
                            <option value="update_asc" data-i18n="steam.sort.updateAsc">更新时间（升序）</option>
                            <option value="update_desc" data-i18n="steam.sort.updateDesc">更新时间（降序）</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <button class="btn btn-primary" onclick="loadSubscriptions()" data-i18n="steam.refresh">刷新订阅内容</button>
                    </div>
                </div>
                
                <div id="subscriptions-result">
                    <!-- 卡片容器 -->
                    <div id="subscriptions-list" class="cards-container">
                        <!-- 空状态 -->
                        <div class="empty-state">
                            <p id="loading-text"></p>
                            <button class="btn btn-secondary" onclick="loadSubscriptions()" id="reload-button"></button>
                        </div>
                    </div>
                    
                    <div class="pagination">
                        <button class="btn btn-secondary" onclick="goToPrevPage()" disabled data-i18n="common.prevPage">上一页</button>
                        <span>第 1 页，共 1 页</span>
                        <button class="btn btn-secondary" onclick="goToNextPage()" disabled data-i18n="common.nextPage">下一页</button>
                    </div>
                </div>
                </div>
            </div>
            <!-- 本地内容标签页 -->
            <div id="local-items-content" class="tab-content" style="display: none;">
                <!-- 上传表单区域 - 默认隐藏 -->
                <div class="section-card upload-section" style="display: none;">
                    <div class="section-header">
                        <h2 data-i18n="steam.uploadToWorkshop">上传到创意工坊</h2>
                    </div>
                    
                    <div id="message-area"></div>
                    
                    <div class="control-group">
                        <div class="control-label" data-i18n="steam.title">标题 *</div>
                        <input type="text" id="item-title" class="control-input" placeholder="输入您的创作标题">
                    </div>
                    
                    <div class="control-group">
                        <div class="control-label" data-i18n="steam.description">描述</div>
                        <textarea id="item-description" class="control-input" placeholder="详细描述您的创作内容..." data-i18n-placeholder="steam.descriptionPlaceholder"></textarea>
                    </div>
                    
                    <div class="control-group">
                        <div class="control-label" data-i18n="steam.contentFolderPath">内容文件夹路径 *</div>
                        <input type="text" id="content-folder" class="control-input" placeholder="从本地物品中获取的内容文件夹路径" readonly>
                    </div>
                    
                    <div class="control-group">
                        <div class="control-label" data-i18n="steam.previewImagePath">预览图片路径 *</div>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <input type="text" id="preview-image" class="control-input" placeholder="从本地物品中获取的预览图片路径">
                            <input type="file" id="preview-image-file" accept="image/*" style="display: none;">
                            <button class="btn btn-secondary" onclick="selectPreviewImage()" data-i18n="common.selectFile">选择文件</button>
                        </div>
                        <div class="control-hint" style="color: red; font-size: 14px;" data-i18n="steam.previewImageSizeHint">提示：预览图片大小需要小于1MB</div>
                    </div>
                    
                    <div class="control-group">
                        <div class="control-label" data-i18n="steam.tags">标签</div>
                        <input type="text" id="item-tags" class="control-input" placeholder="输入标签，按空格添加" data-i18n-placeholder="steam.tagsPlaceholderSpace">
                        <div id="tags-container" class="tags-container"></div>
                    </div>
                    
                    <div class="control-group">
                        <div class="control-label" data-i18n="steam.visibility">可见性</div>
                        <select id="visibility" class="control-select">
                            <option value="public" data-i18n="steam.visibilityPublic">公开</option>
                              <option value="friends" data-i18n="steam.visibilityFriends">仅好友可见</option>
                              <option value="private" data-i18n="steam.visibilityPrivate">私有</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <div class="checkbox-container">
                            <input type="checkbox" id="allow-comments" class="control-checkbox" checked>
                            <label for="allow-comments" class="checkbox-label" data-i18n="steam.allowComments">允许评论</label>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <button class="btn btn-primary" onclick="uploadItem()">
                            <span data-i18n="steam.uploadToWorkshop">上传到创意工坊</span>
                        </button>
                        <button class="btn btn-secondary" onclick="toggleUploadSection()">
                            <span data-i18n="steam.hideUploadSection">隐藏上传区</span>
                        </button>
                        <div class="help-text" style="margin-top: 10px; font-size: 12px; color: #666;">
                            点击"上传"即表示您同意 Steam 创意工坊服务条款，包括创意工坊法律协议：
                            <a href="https://steamcommunity.com/sharedfiles/workshoplegalagreement" target="_blank" style="color: #44b7fe;">https://steamcommunity.com/sharedfiles/workshoplegalagreement</a>
                        </div>
                    </div>
                </div>
                
                <div class="section-card">
                    <div class="section-header">
                        <h2 data-i18n="steam.localItems">管理本地物品</h2>
                    </div>
                    
                    <!-- 搜索和排序功能区域 -->
                    <div class="filter-controls">
                        <div class="filter-group">
                            <div class="filter-label" data-i18n="steam.search">搜索：</div>
                            <input type="text" id="search-local-items" class="control-input" placeholder="搜索本地物品..." data-i18n-placeholder="steam.searchLocalItems">
                        </div>
                        <div class="filter-group">
                            <div class="filter-label" data-i18n="steam.sort.title">排序：</div>
                            <select id="sort-local-items" class="control-select">
                                <option value="name_asc" data-i18n="steam.sort.nameAsc">名称（升序）</option>
                                <option value="name_desc" data-i18n="steam.sort.nameDesc">名称（降序）</option>
                                <option value="date_asc" data-i18n="steam.sort.createDateAsc">创建日期（升序）</option>
                                <option value="date_desc" data-i18n="steam.sort.createDateDesc">创建日期（降序）</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <button class="btn btn-primary" onclick="scanLocalItems()" style="min-width: 160px;">
                                <span data-i18n="steam.scanLocalItems">扫描本地物品</span>
                            </button>
                            <button class="btn btn-primary" onclick="toggleSettingsPanel()" style="min-width: 180px;">
                                <span id="settings-toggle-icon">⚙️</span> <span data-i18n="steam.configurePath">配置路径</span>
                            </button>
                        </div>
                    </div>
                    
                    <!-- 路径配置区域 - 可折叠 -->
                    <div class="settings-container">
                        
                        <div id="settings-panel" class="config-section" style="display: none;">
                            <h3 data-i18n="steam.localModPathConfig">本地mod路径配置</h3>
                            
                            <div class="control-group">
                                <div class="control-label" data-i18n="steam.localModFolder">本地mod文件夹路径</div>
                                <input type="text" id="default-workshop-folder" class="control-input" data-i18n-placeholder="steam.localModFolder" placeholder="本地mod文件夹路径">
                                <div class="help-text" data-i18n="steam.defaultPathHint">未指定扫描路径时将使用此默认路径</div>
                                <div class="help-text success" data-i18n="steam.defaultPathExample">提示：默认路径通常在 我的文档/N.E.K.O/live2d</div>
                            </div>
                            

                            
                            <div class="button-group" style="gap: 10px;">
                                <button class="btn btn-secondary" onclick="loadDefaultConfig()" data-i18n="steam.loadConfig">加载当前配置</button>
                                <button class="btn btn-success" onclick="saveDefaultConfig()" data-i18n="steam.saveConfig">保存配置</button>
                            </div>
                        </div>
                    </div>
                    
                    <div id="local-items-list" class="cards-container">
                        <div class="empty-state">
                            <p data-i18n="steam.emptyStateHint">请输入并扫描一个包含本地文件的文件夹</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 角色卡标签页 -->
            <div id="character-cards-content" class="tab-content" style="display: none;">
                <!-- 角色卡列表 -->

                <div class="section-card">
                    <div class="section-header" style="display: flex; justify-content: space-between; align-items: center;">
                         <h2 data-i18n="steam.characterCardsList">角色卡列表</h2>
                         <button id="new-character-card-btn" class="btn btn-primary" title="创建新角色卡" onclick="clearCharacterCardForm()" style="width: 36px; height: 36px; padding: 0; display: flex; justify-content: center; align-items: center; font-size: 24px; line-height: 1;">
                             +
                         </button>
                      </div>
                    
                    <div id="character-cards-list" class="cards-container">
                        <!-- 角色卡列表将通过JavaScript动态生成 -->
                        <div class="empty-state">
                            <p data-i18n="steam.noCharacterCards">暂无角色卡</p>
                            <button class="btn btn-secondary" onclick="loadCharacterCards()" data-i18n="steam.refresh">刷新列表</button>
                        </div>
                    </div>
                </div>

                <!-- 角色卡管理区域 -->
                <div class="section-card">
                    <div class="section-header">
                         <h2 data-i18n="steam.characterCards">角色卡管理</h2>
                      </div>

                    <div class="character-card-layout" id="character-card-layout">
                        <!-- 左侧显示区域（只读） -->
                        <div class="character-card-inputs">
                            <div class="control-group">
                                <div class="control-label" data-i18n="steam.characterCardName">角色名称</div>
                                <div style="position: relative;">
                                    <input type="text" id="character-card-name" class="control-input">
                                    <span id="edit-mode-lock" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); color: #666; display: none;">
                                        🔒 <span data-i18n="steam.editMode">编辑模式</span>
                                    </span>
                                </div>
                            </div>
                            
                            <div class="control-group">
                                <div class="control-label" data-i18n="steam.characterCardGender">性别</div>
                                <input type="text" id="character-card-gender" class="control-input">
                            </div>
                            
                            <div class="control-group">
                                <div class="control-label" data-i18n="steam.characterCardAge">年龄</div>
                                <input type="text" id="character-card-age" class="control-input">
                            </div>
                            
                            <div class="control-group">
                                <div class="control-label" data-i18n="steam.characterCardDescription">描述</div>
                                <textarea id="character-card-description" class="control-input" style="white-space: pre-wrap; min-height: 100px;"></textarea>
                            </div>
                            
                            <div class="control-group">
                                <div class="control-label" data-i18n="steam.characterCardSetting">角色设定</div>
                                <div style="color: #999; font-size: 12px; " data-i18n="steam.characterCardSettingEnglishOnly"></div>
                                <textarea id="character-card-setting" class="control-input" style="white-space: pre-wrap; min-height: 100px;"></textarea>

                            </div>
                            
                            <div class="control-group">
                                <div class="control-label" data-i18n="steam.characterCardModel">Live2D模型</div>
                                <div id="character-card-model-selection">
                                    <!-- 模型选择区域 -->
                                    <div style="display: flex; gap: 8px; margin-bottom: 10px;">
                                        <select id="model-select" class="control-input" style="width: 100%; padding-right: 25px; cursor: pointer;">
                                            <option value="">未选择模型</option>
                                        </select>
                                        <button class="btn btn-secondary" onclick="openModelDirectory()" style="cursor: pointer; white-space: nowrap;" disabled>打开目录</button>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="control-group">
                                <div class="control-label">角色音色</div>
                                <div id="character-card-voice-selection">
                                    <!-- 音色选择区域 -->
                                    <div class="control-group" style="margin-bottom: 20px;">
                                        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
                                            <select id="voice-select" class="control-input" style="width: 100%; padding-right: 25px; cursor: pointer;">
                                                <option value="">未选择音色</option>
                                            </select>
                                            <button class="btn btn-secondary" onclick="registerVoice()" style="cursor: pointer; white-space: nowrap;">注册音色</button>
                                        </div>
                                        <div style="color: #888; font-size: 12px; margin-top: 5px;">如有音色文件请一起放入模型目录，文件名请使用数字和英文字母</div>
                                    </div>
                                    
                                    <!-- 注册音色表单 -->
                                    <div class="control-group" style="margin-bottom: 20px; padding: 10px; background-color: #f5f5f5; border-radius: 8px; box-sizing: border-box;">
                                        <div class="control-label">注册新音色</div>
                                        <div style="margin-bottom: 10px;">
                                            <label data-i18n="voice.selectFile">选择本地音频文件（15秒最佳，请勿超过45秒，wav/mp3格式）</label>
                                        </div>
                                        <div class="file-input-wrapper" style="margin-bottom: 15px;">
                                            <input type="file" id="audioFile" accept="audio/*" style="display: none;">
                                            <label for="audioFile" class="btn btn-secondary" id="fileInputLabel" data-i18n="voice.chooseFile">选择文件</label>
                                            <span class="file-name-display" id="fileNameDisplay" data-i18n="voice.noFileSelected" style="margin-left: 10px; color: #666; font-size: 14px;">未选择文件</span>
                                        </div>
                                        <div class="field-row" style="margin-bottom: 15px;">
                                            <label data-i18n="voice.customPrefix">自定义前缀（阿里云需要）</label>
                                            <label class="hint" data-i18n="voice.customPrefixNote" style="font-weight: normal; font-size: 12px; color: #888; display: block; margin-bottom: 5px;">不超过10个字符，只支持数字和英文字母</label>
                                            <input type="text" id="prefix" data-i18n-placeholder="voice.prefixPlaceholder" placeholder="不超过10个字符，只支持数字和英文字母" required style="max-width: 600px; width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box;">
                                        </div>
                                        <div class="result" id="voice-register-result" style="margin-top: 10px; font-size: 14px;"></div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="control-group">
                                <div class="control-label" data-i18n="steam.characterCardTags">角色卡标签</div>
                                <div id="character-card-tags-wrapper" style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap; padding: 8px; border: 1px solid #ddd; border-radius: 8px; background-color: #f9f9f9;">
                                    <div class="tags-container" id="character-card-tags-container"></div>
                                    <input type="text" id="character-card-tag-input" placeholder="输入标签后按空格添加" style="flex: 1; min-width: 150px; padding: 4px 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px;">
                                </div>
                            </div>
                            
                            <div class="control-group">
                                <div class="control-label" data-i18n="steam.characterNotes">注意事项</div>
                                <div id="notes-input-container">
                                    <input type="text" id="notes-input" placeholder="输入注意事项（最多30字）" maxlength="30" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 8px; background-color: #f9f9f9; font-size: 14px;">
                                    <div id="notes-counter" style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">0/30</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- 右侧预览区域 -->
                        <div class="character-card-preview">
                            <h3 data-i18n="steam.live2dPreview">Live2D</h3>
                            <div id="live2d-preview-container" style="width: 100%; height: 400px; border: 1px solid #eaeaea; border-radius: 4px; overflow: hidden; background-color: #f8f8f8; display: flex; flex-direction: column; position: relative;">
                                <!-- Live2D预览内容区域 -->
                                <div id="live2d-preview-content" style="flex: 1; position: relative; min-height: 0; pointer-events: none;">
                                    <!-- Live2D预览Canvas -->
                                    <canvas id="live2d-preview-canvas" style="display: none; width: 100%; height: 100%; position: absolute; top: 0; left: 0; pointer-events: none;"></canvas>
                                    <!-- 占位符 -->
                                    <div class="preview-placeholder" style="display: flex; justify-content: center; align-items: center; height: 100%; color: #666; position: relative; z-index: 1;">
                                        <span data-i18n="steam.selectModelToPreview">请选择模型进行预览</span>
                                    </div>
                                    <!-- 防止点击的覆盖层 -->
                                    <div id="live2d-preview-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; pointer-events: auto;"></div>
                                    <!-- 刷新按钮 -->
                                    <button id="live2d-refresh-btn" style="position: absolute; top: 10px; right: 10px; z-index: 101; width: 30px; height: 30px; border: none; border-radius: 50%; background-color: rgba(0, 0, 0, 0.5); color: white; cursor: pointer; display: flex; justify-content: center; align-items: center; font-size: 16px; pointer-events: auto;" title="刷新Live2D预览" onclick="refreshLive2DPreview()">
                                        ↻
                                    </button>
                                </div>
                                <!-- 动作和表情预览控件 -->

                        </div>
                            <div id="live2d-preview-controls" style="padding: 10px; background-color: #f0f0f0; border-top: 1px solid #e0e0e0;">
                                <div style="display: flex; gap: 10px; margin-bottom: 10px; flex-wrap: wrap;">
                                    <div style="flex: 1; min-width: 150px;">
                                        <select id="preview-motion-select" class="control-input" style="width: 100%;">
                                            <option value="">选择动作</option>
                                        </select>
                                    </div>
                                    <button id="preview-play-motion-btn" class="btn btn-primary" style="padding: 5px 15px;" disabled>
                                        播放动作
                                    </button>
                                </div>
                                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                                    <div style="flex: 1; min-width: 150px;">
                                        <select id="preview-expression-select" class="control-input" style="width: 100%;">
                                            <option value="">选择表情</option>
                                        </select>
                                    </div>
                                    <button id="preview-play-expression-btn" class="btn btn-primary" style="padding: 5px 15px;" disabled>
                                        播放表情
                                    </button>
                                </div>
                            </div>
                            
                            <hr class="fluent-divider">
                            
                            <h3 data-i18n="steam.cardInfoPreview">角色卡信息</h3>
                            <div id="card-info-preview" style="padding: 12px; border: 1px solid #eaeaea; border-radius: 4px; background-color: #f8f8f8;">
                                <div id="preview-card-name" style="color: #555; margin-bottom: 8px;"><strong data-i18n="steam.characterCardName">角色卡名称:</strong> <span style="font-weight: normal;">-</span></div>
                                <div id="preview-card-gender" style="color: #555; margin-bottom: 8px;"><strong data-i18n="steam.characterCardGender">性别:</strong> <span style="font-weight: normal;">-</span></div>
                                <div id="preview-card-age" style="color: #555; margin-bottom: 8px;"><strong data-i18n="steam.characterCardAge">年龄:</strong> <span style="font-weight: normal;">-</span></div>
                                <div id="preview-card-description" style="color: #555; margin-bottom: 8px;"><strong data-i18n="steam.characterCardDescription">角色卡描述:</strong> <span style="font-weight: normal;">-</span></div>
                                <div id="preview-card-setting" style="color: #555; margin-bottom: 8px; font-style: italic;"><strong data-i18n="steam.characterCardSetting">角色设定:</strong> <span style="font-weight: normal;">-</span></div>
                                <div id="preview-card-voice" style="color: #555; margin-bottom: 8px;"><strong data-i18n="steam.characterCardVoice">角色音色:</strong> <span style="font-weight: normal;">-</span></div>
                            </div>
                            
                            <hr class="fluent-divider">
                            
                            <h3 data-i18n="steam.tagsPreview">标签</h3>
                            <div id="tags-preview" style="padding: 12px; border: 1px solid #eaeaea; border-radius: 4px; background-color: #f8f8f8;">
                                <div class="tags-container" id="preview-tags-container">
                                    <!-- 标签预览将在这里显示 -->
                                </div>
                            </div>
                            
                            <h3 data-i18n="steam.notesPreview">注意事项</h3>
                            <div id="notes-preview" style="padding: 12px; border: 1px solid #eaeaea; border-radius: 4px; background-color: #f8f8f8;">
                                <div class="tags-container" id="preview-notes-container">
                                    <!-- 注意事项预览将在这里显示 -->
                                </div>
                            </div>
                            
                            <div class="save-button-container">
                                <button id="save-character-card-btn" class="btn btn-success" onclick="saveCharacterCard()" style="flex: 1; padding: 12px 0; font-size: 16px;">
                                    💾 <span data-i18n="common.save">保存角色卡</span>
                                </button>
                                <button class="btn btn-primary" onclick="handleUploadToWorkshop()" style="flex: 1; padding: 12px 0; font-size: 16px;">
                                    🚀 <span data-i18n="steam.uploadToWorkshop">上传到创意工坊</span>
                                </button>
                                <button class="btn" style="flex: 1; padding: 12px 0; font-size: 16px; background-color: #e81123; color: white;" onclick="deleteCharacterCardModal()">
                                    🗑️ 删除角色卡
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                

            </div>
            
            <!-- 上传内容标签页 -->
            <div id="upload-content" class="tab-content" style="display: none;">
                <!-- 已移除重复的上传页面，统一使用本地物品标签页中的上传功能 -->
            </div>
        </div>
    </div>
    </div>

    <!-- 物品详情模态框 -->
    <div id="itemDetailsModal" class="modal" onclick="closeModalOnOutsideClick(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h3 class="modal-title" id="modalTitle" data-i18n="steam.itemDetails">物品详情</h3>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div id="itemDetailContent" class="item-detail-container">
                    <!-- 物品详情内容将通过JavaScript动态加载 -->
                    <div class="empty-state">
                        <p data-i18n="steam.loadingItemDetails">正在加载物品详情...</p>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal()" data-i18n="steam.close">关闭</button>
            </div>
        </div>
    </div>



    <script>
        // 点击模态框外部关闭
        function closeModalOnOutsideClick(event) {
            const modal = document.getElementById('itemDetailsModal');
            if (event.target === modal) {
                closeModal();
            }
        }
        
        // 上传区域切换功能
        function toggleUploadSection() {
            // 查找上传表单区域
            console.log('toggleUploadSection函数被调用');
            const uploadFormSection = document.querySelector('.upload-section');
            console.log('找到的上传表单区域:', uploadFormSection);
            if (uploadFormSection) {
                // 切换上传表单的显示/隐藏
                console.log('当前上传表单区域的display样式:', uploadFormSection.style.display);
                if (uploadFormSection.style.display === 'none' || uploadFormSection.style.display === '') {
                    uploadFormSection.style.display = 'block';
                    // 滚动到上传表单区域
                    uploadFormSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    // 手动更新选择文件按钮的翻译
                    const selectFileButton = document.querySelector('button[data-i18n="common.selectFile"]');
                    console.log('找到的选择文件按钮:', selectFileButton);
                    if (selectFileButton && window.t) {
                        const translatedText = window.t('common.selectFile');
                        console.log('common.selectFile的翻译:', translatedText);
                        selectFileButton.textContent = translatedText;
                    }
                    // 更新翻译，确保新显示的元素都能正确翻译
                    if (window.updatePageTexts) {
                        window.updatePageTexts();
                    }
                    console.log('上传表单区域已显示');
                } else {
                    uploadFormSection.style.display = 'none';
                    console.log('上传表单区域已隐藏');
                }
            } else {
                console.log('未找到上传表单区域');
            }
        }
        
        // 本地物品区域切换功能
        function toggleLocalItemsSection() {
            const localItemsSection = document.getElementById('local-items');
            const toggleButton = document.getElementById('local-items-toggle-button');

            // 确保本地物品内容标签页可见
            const localItemsContent = document.getElementById('local-items-content');
            if (localItemsContent && localItemsContent.style.display === 'none') {
                switchTab('local-items-content');
                return;
            }

            // 切换本地物品区域的显示/隐藏
            if (localItemsSection && localItemsSection.style.display === 'none') {
                // 先扫描本地物品
                scanLocalItems();
                localItemsSection.style.display = 'block';
                if (toggleButton) {
                    toggleButton.textContent = window.t ? window.t('steam.localItemsHide') : '隐藏本地物品';
                }
                // 更新翻译，确保新显示的元素都能正确翻译
                if (window.updatePageTexts) {
                    window.updatePageTexts();
                }
                // 平滑滚动到本地物品区域
                localItemsSection.scrollIntoView({ behavior: 'smooth' });
            } else if (localItemsSection) {
                localItemsSection.style.display = 'none';
                if (toggleButton) {
                    toggleButton.textContent = window.t ? window.t('steam.localItemsManage') : '管理本地物品';
                }
            }
        }

        // 标签页切换功能
        // 从localStorage加载同步数据并填充到创意工坊上传表单
        function applyWorkshopSyncData() {
            try {
                // 从localStorage获取同步数据
                const workshopSyncDataStr = localStorage.getItem('workshopSyncData');
                if (workshopSyncDataStr) {
                    const workshopSyncData = JSON.parse(workshopSyncDataStr);
                    console.log('从localStorage加载的同步数据:', workshopSyncData);
                    
                    // 1. 填充标签
                    const tagsContainer = document.getElementById('tags-container');
                    if (tagsContainer) {
                        // 清空现有标签
                        tagsContainer.innerHTML = '';
                        
                        // 添加从角色卡同步的标签
                        if (workshopSyncData.tags && Array.isArray(workshopSyncData.tags)) {
                            workshopSyncData.tags.forEach(tag => {
                                addTag(tag);
                            });
                        }
                    }
                    
                    // 2. 填充描述（包含注意事项）
                    const itemDescription = document.getElementById('item-description');
                    if (itemDescription) {
                        let newDescription = workshopSyncData.description || '';
                        
                        // 如果有注意事项，将其添加到描述后面
                        if (workshopSyncData.notes && workshopSyncData.notes.trim()) {
                            // 如果描述不为空，添加两个换行符作为分隔
                            if (newDescription.trim()) {
                                newDescription += '\n\n';
                            }
                            // 根据当前语言选择注意事项标题
                            const currentLanguage = typeof i18next !== 'undefined' ? i18next.language : 'zh-CN';
                            const notesTitle = currentLanguage === 'zh-CN' ? '注意事项：\n' : 'Notes:\n';
                            newDescription += notesTitle + workshopSyncData.notes.trim();
                        }
                        
                        itemDescription.value = newDescription;
                        console.log('设置的描述内容:', newDescription);
                    } else {
                        console.error('未找到创意工坊描述输入框');
                    }
                } else {
                    console.log('localStorage中没有同步数据');
                }
            } catch (error) {
                console.error('应用同步数据时出错:', error);
            }
        }
        
        function switchTab(tabId, event) {
            
            // 隐藏所有标签内容
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => {
                content.style.display = 'none';
            });

            // 移除所有标签按钮的活动状态
            const tabButtons = document.querySelectorAll('.tab');
            tabButtons.forEach(button => {
                button.classList.remove('active');
            });

            // 为当前点击的标签按钮添加活动状态
            if (event && event.target) {
                const clickedButton = event.target;
                clickedButton.classList.add('active');
            } else {
                // 非点击事件调用时，通过tabId找到对应的标签按钮
                const matchingTab = Array.from(tabButtons).find(btn =>
                    btn.getAttribute('onclick') && btn.getAttribute('onclick').includes(tabId)
                );
                if (matchingTab) {
                    matchingTab.classList.add('active');
                }
            }

            // 显示选中的标签内容
            const selectedTab = document.getElementById(tabId);
            if (selectedTab) {
                selectedTab.style.display = 'block';
                // 更新翻译，确保新显示的元素都能正确翻译
                if (window.updatePageTexts) {
                    window.updatePageTexts();
                }
            }

            // 设置选中的标签按钮为活动状态（兼容旧的标签按钮）
            tabButtons.forEach(button => {
                if (button.getAttribute('onclick') && button.getAttribute('onclick').includes(tabId)) {
                    button.classList.add('active');
                }
            });

            // 设置侧边栏中对应的按钮为活动状态
            const sidebarButtons = document.querySelectorAll('.sidebar-tab-button');
            if (sidebarButtons.length > 0) {
                sidebarButtons.forEach(button => {
                    if (button.getAttribute('onclick') && button.getAttribute('onclick').includes(tabId)) {
                        button.classList.add('active');
                    }
                });
            }
            

                
                // 确保上传表单区域初始隐藏
                const uploadFormSection = document.querySelector('.upload-section');
                if (uploadFormSection) {
                    uploadFormSection.style.display = 'none';
                }
            
            // 如果切换到角色卡页面，自动执行模型扫描
            if (tabId === 'character-cards-content') {
                scanModels();
            }
            
            // 如果切换到本地物品页面，应用从localStorage加载的同步数据
            if (tabId === 'local-items-content') {
                applyWorkshopSyncData();
            }
        }

        // 提示：由于浏览器安全限制，浏览按钮仅提供路径输入提示

        // 选择文件夹并填充到指定输入框
        async function selectFolderForInput(inputId) {
            try {
                // 检查浏览器是否支持 File System Access API
                if (!('showDirectoryPicker' in window)) {
                    showMessage(window.t ? window.t('steam.folderPickerNotSupported') : '当前浏览器不支持目录选择，请手动输入路径', 'warning');
                    // 移除 readonly 属性让用户可以手动输入
                    document.getElementById(inputId).removeAttribute('readonly');
                    return;
                }

                const dirHandle = await window.showDirectoryPicker({
                    mode: 'read'
                });

                // 获取选中目录的路径（通过目录名称）
                // 注意：File System Access API 不直接提供完整路径，只提供目录名称
                // 我们需要通知用户已选择的目录名
                const folderName = dirHandle.name;

                // 由于浏览器安全限制，无法获取完整路径
                // 提示用户输入完整路径
                showMessage(window.t ? window.t('steam.folderSelectedPartial', { name: folderName }) :
                    `已选择目录: "${folderName}"。由于浏览器安全限制，请手动输入完整路径`, 'warning');

                // 移除 readonly 让用户可以输入完整路径
                document.getElementById(inputId).removeAttribute('readonly');
                document.getElementById(inputId).focus();

            } catch (error) {
                if (error.name === 'AbortError') {
                    // 用户取消了选择
                    showMessage(window.t ? window.t('steam.folderSelectionCancelled') : '已取消目录选择', 'info');
                } else {
                    console.error('选择目录失败:', error);
                    showMessage(window.t ? window.t('steam.folderSelectionError') : '选择目录失败', 'error');
                }
            }
        }

        // 加载默认配置 - 优先使用 live2d_dir 作为默认值
        function loadDefaultConfig() {
            showMessage(window.t ? window.t('steam.loadingConfig') : '正在加载配置...', 'info');

            // 先获取系统 live2d_dir 作为默认值
            Promise.all([
                fetch('/api/steam/workshop/config').then(r => r.json()),
                fetch('/api/config/info').then(r => r.json()).catch(() => ({ live2d_dir: '' }))
            ])
                .then(([workshopData, configInfo]) => {
                    if (workshopData.success) {
                        // 优先使用用户配置的路径，否则使用 live2d_dir
                        const live2dDir = configInfo.live2d_dir || '';
                        const defaultFolder = workshopData.config.user_mod_folder ||
                            workshopData.config.default_workshop_folder ||
                            live2dDir;

                        document.getElementById('default-workshop-folder').value = defaultFolder;

                        showMessage(window.t ? window.t('steam.configLoadSuccess') : '配置加载成功', 'success');
                    } else {
                        showMessage(window.t ? window.t('steam.configLoadFailed', { error: workshopData.error || (window.t ? window.t('common.unknownError') : '未知错误') }) : `配置加载失败: ${workshopData.error || '未知错误'}`, 'error');
                    }
                })
                .catch(error => {
                    console.error('加载配置时出错:', error);
                    showMessage(window.t ? window.t('steam.configLoadError', { error: error.message }) : `配置加载错误: ${error.message}`, 'error');
                });
        }

        // 保存默认配置
        function saveDefaultConfig() {
            const defaultFolder = document.getElementById('default-workshop-folder').value.trim();

            // 验证默认文件夹路径格式（如果提供了）
            if (defaultFolder && defaultFolder.length < 3) {
                showMessage(window.t ? window.t('steam.invalidFolderPath') : '无效的文件夹路径', 'error');
                return;
            }

            showMessage(window.t ? window.t('steam.savingConfig') : '正在保存配置...', 'info');

            fetch('/api/steam/workshop/config', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    user_mod_folder: defaultFolder
                })
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        showMessage(window.t ? window.t('steam.configSaveSuccess') : '配置保存成功', 'success');
                    } else {
                        showMessage(window.t ? window.t('steam.configSaveFailed', { error: data.error || (window.t ? window.t('common.unknownError') : '未知错误') }) : `配置保存失败: ${data.error || '未知错误'}`, 'error');
                    }
                })
                .catch(error => {
                    console.error('保存配置时出错:', error);
                    showMessage(window.t ? window.t('steam.configSaveError', { error: error.message }) : `配置保存错误: ${error.message}`, 'error');
                });
        }

        // 切换设置面板的显示/隐藏
        function toggleSettingsPanel() {
            const panel = document.getElementById('settings-panel');
            const icon = document.getElementById('settings-toggle-icon');
            // 使用icon的父元素作为toggleButton，因为按钮的类已经更改
            const toggleButton = icon.parentElement;

            if (panel.style.display === 'none') {
                // 显示面板，添加简单动画效果
                panel.style.display = 'block';
                // 更新翻译，确保新显示的元素都能正确翻译
                if (window.updatePageTexts) {
                    window.updatePageTexts();
                }
                panel.style.opacity = '0';
                panel.style.transition = 'opacity 0.3s ease-in-out';

                // 强制重绘
                void panel.offsetWidth;

                // 设置透明度为1，触发过渡动画
                panel.style.opacity = '1';

                // 更新按钮文字和图标
                icon.textContent = '▼';
                toggleButton.classList.remove('btn-secondary');
                toggleButton.classList.add('btn-primary');
            } else {
                // 隐藏面板，添加简单动画效果
                panel.style.opacity = '0';
                panel.style.transition = 'opacity 0.3s ease-in-out';

                // 动画结束后隐藏
                setTimeout(() => {
                    panel.style.display = 'none';
                }, 300);

                // 更新按钮文字和图标
                icon.textContent = '⚙️';
                toggleButton.classList.remove('btn-primary');
                toggleButton.classList.add('btn-secondary');
            }
        }



        // 扫描本地物品 - 现在仅使用默认路径
        function scanLocalItems() {
            console.log('开始扫描本地物品...');

            // 显示扫描开始提示
            const startMessage = showMessage(window.t ? window.t('steam.scanningWorkshop') : '正在扫描Workshop物品...', 'info');
            console.log('已显示扫描开始提示');

            // 调用API扫描本地文件夹中的物品
            fetch('/api/steam/workshop/local-items/scan', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({})
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP错误，状态码: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('扫描完成，数据返回:', data);
                
                if (data.success) {
                    // 获取本地物品列表
                    const localItems = data.local_items || [];
                    const publishedItems = data.published_items || [];
                    
                    // 更新UI显示本地物品
                    displayLocalItems(localItems, publishedItems);
                    
                    
                    // 直接显示扫描完成提示，使用简单清晰的消息
                    const successMessage = window.t ? window.t('steam.scanComplete', {count: localItems.length}) : `扫描完成，共找到 ${localItems.length} 个物品`;
console.log('准备显示成功提示:', successMessage);
                    
                    // 使用独立的提示元素，确保与开始提示分开
                    const messageElement = document.createElement('div');
                    messageElement.innerHTML = successMessage;
                    messageElement.style.cssText = `
                        position: fixed;
                        top: 60px;
                        right: 20px;
                        padding: 15px 20px;
                        background: #e8f5e9;
                        color: #2e7d32;
                        border-radius: 6px;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                        z-index: 99999;
                        font-weight: bold;
                        opacity: 0;
                        transform: translateY(-10px);
                        transition: opacity 0.3s ease, transform 0.3s ease;
                    `;

                        document.body.appendChild(messageElement);

                        // 触发动画
                        setTimeout(() => {
                            messageElement.style.opacity = '1';
                            messageElement.style.transform = 'translateY(0)';
                        }, 10);

                        // 5秒后自动消失
                        setTimeout(() => {
                            messageElement.style.opacity = '0';
                            messageElement.style.transform = 'translateY(-10px)';
                            setTimeout(() => {
                                messageElement.remove();
                            }, 300);
                        }, 3000);

                        console.log('成功提示已显示');
                    } else {
                        const errorMessage = window.t ? window.t('steam.scanFailed', { error: data.error || (window.t ? window.t('common.unknownError') : '未知错误') }) : `扫描失败: ${data.error || '未知错误'}`;
                        showMessage(errorMessage, 'error', 3000);
                    }
                })
                .catch(error => {
                    console.error('扫描本地物品失败:', error);
                    showMessage(window.t ? window.t('steam.workshopScanError', { error: error.message }) : `扫描时出错: ${error.message}`, 'error', 3000);
                });
        }

        // 检查文件是否存在
        async function doesFileExist(filePath) {
            try {
                const response = await fetch(`/api/file-exists?path=${encodeURIComponent(filePath)}`);
                const result = await response.json();
                return result.exists;
            } catch (error) {
                // 如果API不可用，返回false
                return false;
            }
        }

        // 查找预览图片
        async function findPreviewImage(folderPath) {
            try {
                // 尝试查找常见的预览图片文件
                const commonImageNames = ['preview.jpg', 'preview.png', 'thumbnail.jpg', 'thumbnail.png', 'icon.jpg', 'icon.png', 'header.jpg', 'header.png'];

                for (const imageName of commonImageNames) {
                    const imagePath = `${folderPath}/${imageName}`;
                    if (await doesFileExist(imagePath)) {
                        return imagePath;
                    }
                }

                // 如果找不到常见预览图，尝试使用API获取文件夹中的第一个图片文件
                const response = await fetch(`/api/find-first-image?folder=${encodeURIComponent(folderPath)}`);
                const result = await response.json();

                if (result.success && result.imagePath) {
                    return result.imagePath;
                }
            } catch (error) {
                console.error('查找预览图片失败:', error);
            }

            return null;
        }

        // 创意工坊物品对比
        async function compareLocalWithWorkshop(localItem) {
            try {
                // 获取已发布的创意工坊物品
                const workshopItems = await getWorkshopItems();

                // 比较名称
                for (const workshopItem of workshopItems) {
                    if (areNamesSimilar(localItem.name, workshopItem.title)) {
                        return {
                            exists: true,
                            item: workshopItem,
                            reason: '名称相似'
                        };
                    }
                }
            } catch (error) {
                console.error('创意工坊对比失败:', error);
            }

            return { exists: false };
        }

        // 检查名称是否相似
        function areNamesSimilar(name1, name2) {
            // 简单的相似度检查，可以根据需要改进
            name1 = name1.toLowerCase().trim();
            name2 = name2.toLowerCase().trim();

            // 如果完全相同，直接返回true
            if (name1 === name2) return true;

            // 如果一个名称包含另一个名称
            if (name1.includes(name2) || name2.includes(name1)) return true;

            // 计算编辑距离（简单版本）
            if (Math.abs(name1.length - name2.length) > 3) return false;

            return false;
        }

        // 获取创意工坊物品列表
        async function getWorkshopItems() {
            try {
                const response = await fetch('/api/steam/workshop/subscribed-items');
                const data = await response.json();
                if (data.success) {
                    return data.items;
                }
            } catch (error) {
                console.error('获取创意工坊物品失败:', error);
            }
            return [];
        }

        // 显示本地物品卡片
        function displayLocalItems(localItems, publishedItems) {
            const itemsList = document.getElementById('local-items-list');

            if (localItems.length === 0) {
                const emptyMessage = window.t ? window.t('steam.no_local_items') : '在指定文件夹中未找到任何创意工坊物品';
                itemsList.innerHTML = `
                    <div class="empty-state">
                        <p>${emptyMessage}</p>
                    </div>
                `;
                return;
            }

            // 创建物品卡片HTML
            itemsList.innerHTML = localItems.map(item => {
                // 检查该物品是否已发布到创意工坊
                const isPublished = publishedItems.some(published =>
                    published.localId === item.id ||
                    (published.title && item.name &&
                        published.title.toLowerCase() === item.name.toLowerCase())
                );

                // 确定状态类和文本
                let statusClass = 'status-error';
                let statusText = window.t ? window.t('steam.status.unpublished') : '未发布';

                if (isPublished) {
                    statusClass = 'status-published';
                    statusText = window.t ? window.t('steam.status.published') : '已发布';
                }

                // 生成预览图片URL或使用默认图片
                // 使用图片代理API访问本地图片，避免浏览器安全限制
                // 确保Windows路径中的反斜杠正确编码
                const previewUrl = item.previewImage ? `/api/steam/proxy-image?image_path=${encodeURIComponent(item.previewImage.replace(/\\/g, '/'))}` : '../static/icons/Steam_icon_logo.png';
                
                // 生成卡片HTML，对所有用户输入进行转义以防止XSS攻击
                // 添加data-item-path属性用于后续检查上传标记文件
            }).join('');

            // 生成卡片后，检查每个物品的上传标记文件状态
            checkUploadStatusForLocalItems();
        }

        // 检查本地物品的上传标记文件状态
        function checkUploadStatusForLocalItems() {
            // 获取所有物品卡片
            const itemCards = document.querySelectorAll('.workshop-card');

            itemCards.forEach(card => {
                const itemPath = card.getAttribute('data-item-path');
                if (itemPath) {
                    // 调用后端API检查上传标记文件
                    fetch(`/api/steam/workshop/check-upload-status?item_path=${itemPath}`)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`HTTP错误，状态码: ${response.status}`);
                            }
                            return response.json();
                        })
                        .then(data => {
                            if (data.success && data.is_published) {
                                // 如果存在上传标记文件，更新状态为已发布
                                const statusBadge = card.querySelector('.status-badge');
                                if (statusBadge) {
                                    statusBadge.className = 'status-badge status-published';
                                    statusBadge.textContent = window.t ? window.t('steam.status.published') : '已发布';
                                }

                                // 更新上传按钮状态为已发布
                                const actionButton = card.querySelector('.card-actions button');
                                if (actionButton) {
                                    actionButton.className = 'button button-disabled';
                                    actionButton.disabled = true;
                                    actionButton.textContent = window.t ? window.t('steam.status.published') : '已发布';
                                }
                            }
                        })
                        .catch(error => {
                            console.error('检查上传标记文件失败:', error);
                        });
                }
            });
        }

        // 准备物品上传
        function prepareItemForUpload(itemId, folderPath) {
            // 确保路径格式一致（将Windows反斜杠转换为正斜杠以便正确编码）
            const normalizedPath = folderPath.replace(/\\/g, '/');
            // 调用API获取物品详情
            fetch(`/api/steam/workshop/local-items/${itemId}?folder_path=${encodeURIComponent(normalizedPath)}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP错误，状态码: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        const item = data.item;

                        // 填充上传表单
                        document.getElementById('item-title').value = item.name || '';
                        document.getElementById('content-folder').value = item.path || '';

                        // 如果有预览图片，填充预览图片路径
                        if (item.previewImage) {
                            document.getElementById('preview-image').value = item.previewImage;
                        }

                        // 切换到上传区域
                        toggleUploadSection();

                        showMessage(window.t ? window.t('steam.itemDetailsLoaded') : '物品详情加载成功', 'success');
                    } else {
                        showMessage(window.t ? window.t('steam.itemDetailsFailed', { error: data.error || (window.t ? window.t('common.unknownError') : '未知错误') }) : `物品详情加载失败: ${data.error || '未知错误'}`, 'error');
                    }
                })
                .catch(error => {
                    console.error('准备上传失败:', error);
                    showMessage(window.t ? window.t('steam.prepareUploadError', { error: error.message }) : `准备上传出错: ${error.message}`, 'error');
                });
        }
        
        
        // 格式化日期
        /* 注释掉不完整的formatDate版本 */
        /*
        function formatDate(timestamp) {
            if (!timestamp) return '未知';
            
            const date = new Date(timestamp);
            return date.toLocaleDateString();
        }
        */

        // 添加完整版本的formatDate函数（包含日期和时间）
        function formatDate(timestamp) {
            if (!timestamp) return '未知';

            const date = new Date(timestamp);
            // 使用toLocaleString同时显示日期和时间
            return date.toLocaleString();
        }

        // 文件路径选择辅助功能
        function validatePathInput(elementId) {
            const element = document.getElementById(elementId);
            element.addEventListener('blur', function () {
                const path = this.value.trim();
                if (path && path.includes('\\\\')) {
                    // 将双反斜杠替换为单反斜杠，Windows路径格式
                    this.value = path.replace(/\\\\/g, '\\');
                }
            });
        }

        // 为路径输入框添加验证
        validatePathInput('content-folder');
        validatePathInput('preview-image');

        // 标签管理功能
        const tagInput = document.getElementById('item-tags');
        const tagsContainer = document.getElementById('tags-container');
        
        // 监听输入事件，当输入空格时添加标签
        tagInput.addEventListener('input', (e) => {
            if (e.target.value.endsWith(' ') && e.target.value.trim() !== '') {
                e.preventDefault();
                addTag(e.target.value.trim());
                e.target.value = '';
            }
        });
        
        // 兼容回车键添加标签
        tagInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && e.target.value.trim() !== '') {
                e.preventDefault();
                addTag(e.target.value.trim());
                e.target.value = '';
            }
        });
        
        function addTag(tagText, type = '') {
            // 根据type参数获取对应的标签容器元素
            const containerId = type ? `${type}-tags-container` : 'tags-container';
            const tagsContainer = document.getElementById(containerId);
            if (!tagsContainer) {
                console.error(`Tags container ${containerId} not found`);
                return;
            }
            
            // 检查标签字数限制
            if (tagText.length > 30) {
                showMessage(window.t ? window.t('steam.tagTooLong') : '标签长度不能超过30个字符', 'error');
                return;
            }
            
            // 检查标签数量限制
            const existingTags = Array.from(tagsContainer.querySelectorAll('.tag'));
            if (existingTags.length >= 4) {
                showMessage(window.t ? window.t('steam.tagLimitReached') : '最多只能添加4个标签', 'error');
                return;
            }

            // 检查是否已存在相同标签
            const existingTagTexts = existingTags.map(tag => 
                tag.textContent.replace('×', '').trim()
            );
            
            if (existingTagTexts.includes(tagText)) {
                showMessage(window.t ? window.t('steam.tagExists') : '该标签已存在', 'error');
                return;
            }

            const tagElement = document.createElement('div');
            tagElement.className = 'tag';
            tagElement.innerHTML = `${tagText}<span class="tag-remove" onclick="removeTag(this)">×</span>`;
            tagsContainer.appendChild(tagElement);
        }
        
        function removeTag(tagElement, type = '') {
            if (tagElement && tagElement.parentElement) {
                tagElement.parentElement.remove();
                
                // 更新标签预览
                if (type === 'character-card') {
                    updateTagsPreview();
                }
            } else {
                console.error('Invalid tag element');
            }
        }

        // 消息显示功能 - 增强版
        // 自定义确认模态框
        function showConfirmModal(message, confirmCallback, cancelCallback = null) {
            // 创建确认模态框容器
            const modalOverlay = document.createElement('div');
            modalOverlay.className = 'confirm-modal-overlay';
            
            const modalContainer = document.createElement('div');
            modalContainer.className = 'confirm-modal-container';
            
            const modalContent = document.createElement('div');
            modalContent.className = 'confirm-modal-content';
            
            const modalMessage = document.createElement('div');
            modalMessage.className = 'confirm-modal-message';
            modalMessage.innerHTML = `<i class="fa fa-question-circle" style="margin-right: 8px;"></i>${escapeHtml(message)}`;
            
            const modalActions = document.createElement('div');
            modalActions.className = 'confirm-modal-actions';
            
            // 取消按钮
            const cancelButton = document.createElement('button');
            cancelButton.className = 'btn btn-secondary';
            cancelButton.textContent = '取消';
            cancelButton.onclick = () => {
                modalOverlay.remove();
                if (cancelCallback) cancelCallback();
            };
            
            // 确认按钮
            const confirmButton = document.createElement('button');
            confirmButton.className = 'btn btn-danger';
            confirmButton.textContent = '确认';
            confirmButton.onclick = () => {
                modalOverlay.remove();
                if (confirmCallback) confirmCallback();
            };
            
            // 组装模态框
            modalActions.appendChild(cancelButton);
            modalActions.appendChild(confirmButton);
            modalContent.appendChild(modalMessage);
            modalContent.appendChild(modalActions);
            modalContainer.appendChild(modalContent);
            modalOverlay.appendChild(modalContainer);
            
            // 添加到页面
            document.body.appendChild(modalOverlay);
            
            // 添加CSS样式
            const style = document.createElement('style');
            style.textContent = `
                .confirm-modal-overlay {
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background-color: rgba(0, 0, 0, 0.5);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 9999;
                    animation: fadeIn 0.3s ease;
                }
                
                .confirm-modal-container {
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    width: 100%;
                    height: 100%;
                }
                
                .confirm-modal-content {
                    background-color: white;
                    border-radius: 8px;
                    padding: 24px;
                    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
                    min-width: 400px;
                    max-width: 90%;
                    animation: slideUp 0.3s ease;
                }
                
                .confirm-modal-message {
                    font-size: 16px;
                    color: #333;
                    margin-bottom: 20px;
                    line-height: 1.5;
                }
                
                .confirm-modal-actions {
                    display: flex;
                    justify-content: flex-end;
                    gap: 10px;
                }
                
                @keyframes fadeIn {
                    from { opacity: 0; }
                    to { opacity: 1; }
                }
                
                @keyframes slideUp {
                    from { transform: translateY(20px); opacity: 0; }
                    to { transform: translateY(0); opacity: 1; }
                }
            `;
            document.head.appendChild(style);
        }
        
        function showMessage(message, type = 'info', duration = 3000) {
            const messageArea = document.getElementById('message-area') || createMessageArea();
            const messageElement = document.createElement('div');

            // 创建消息容器（如果不存在）
            function createMessageArea() {
                const container = document.createElement('div');
                container.id = 'message-area';
                container.className = 'message-area';
                document.body.appendChild(container);
                return container;
            }

            // 消息类型和图标映射
            const typeConfig = {
                error: { className: 'error-message', icon: 'fa-exclamation-circle' },
                warning: { className: 'warning-message', icon: 'fa-exclamation-triangle' },
                success: { className: 'success-message', icon: 'fa-check-circle' },
                info: { className: 'info-message', icon: 'fa-info-circle' }
            };

            // 获取当前消息类型的配置
            const config = typeConfig[type] || typeConfig.info;

            // 设置样式类
            messageElement.className = config.className;

            // 设置消息内容，添加图标和HTML转义
            messageElement.innerHTML = `
                <i class="fa ${config.icon}" style="margin-right: 8px;"></i>
                <span>${escapeHtml(message)}</span>
            `;

            // 添加关闭按钮
            const closeButton = document.createElement('span');
            closeButton.className = 'message-close';
            closeButton.innerHTML = '<i class="fa fa-times"></i>';
            closeButton.onclick = () => messageElement.remove();
            messageElement.appendChild(closeButton);

            // 为错误消息添加详细信息支持
            if (type === 'error' && typeof message === 'object') {
                messageElement.title = JSON.stringify(message, null, 2);
            }

            // 添加消息
            messageArea.appendChild(messageElement);

            // 设置初始样式
            messageElement.style.opacity = '0';
            messageElement.style.transform = 'translateY(-10px)';
            messageElement.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
            messageElement.style.display = 'flex';
            messageElement.style.alignItems = 'center';
            messageElement.style.padding = '10px 15px';
            messageElement.style.marginBottom = '10px';
            messageElement.style.borderRadius = '4px';
            messageElement.style.position = 'relative';
            messageElement.style.zIndex = '1000';

            // 为不同类型设置背景色
            const bgColors = {
                error: '#ffebee',
                warning: '#fff8e1',
                success: '#e8f5e9',
                info: '#e3f2fd'
            };
            messageElement.style.backgroundColor = bgColors[type] || '#f5f5f5';

            // 设置消息显示动画
            setTimeout(() => {
                messageElement.style.opacity = '1';
                messageElement.style.transform = 'translateY(0)';
            }, 10);

            // 确保消息区域在页面顶部且固定
            messageArea.style.position = 'fixed';
            messageArea.style.top = '20px';
            messageArea.style.right = '20px';
            messageArea.style.maxWidth = '400px';
            messageArea.style.zIndex = '99999'; // 增加z-index确保显示在最顶层
            messageArea.style.display = 'flex';
            messageArea.style.flexDirection = 'column';
            messageArea.style.alignItems = 'flex-end';
            messageArea.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)'; // 添加阴影增强可见性

            // 关闭按钮样式
            closeButton.style.position = 'absolute';
            closeButton.style.right = '10px';
            closeButton.style.cursor = 'pointer';
            closeButton.style.fontSize = '16px';
            closeButton.style.border = 'none';
            closeButton.style.background = 'none';
            closeButton.style.padding = '2px 5px';
            closeButton.style.borderRadius = '3px';
            closeButton.onmouseover = function () { this.style.backgroundColor = 'rgba(0,0,0,0.1);' };
            closeButton.onmouseout = function () { this.style.backgroundColor = 'transparent;' };

            // 自动清除消息（如果指定了持续时间）
            if (duration > 0) {
                setTimeout(() => {
                    messageElement.style.opacity = '0';
                    messageElement.style.transform = 'translateY(-10px)';
                    setTimeout(() => {
                        messageElement.remove();
                    }, 300);
                }, duration);
            }
        }

        // HTML转义函数
        function escapeHtml(text) {
            if (typeof text !== 'string') {
                return String(text);
            }
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // 加载状态管理器
        function LoadingManager() {
            const loadingCount = { value: 0 };

            return {
                show: function (message = window.t ? window.t('common.loading') : '加载中...') {
                    loadingCount.value++;
                    if (loadingCount.value === 1) {
                        const loadingOverlay = document.createElement('div');
                        loadingOverlay.id = 'loading-overlay';
                        loadingOverlay.style.cssText = `
                            position: fixed;
                            top: 0;
                            left: 0;
                            width: 100%;
                            height: 100%;
                            background: rgba(255, 255, 255, 0.8);
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            justify-content: center;
                            z-index: 9999;
                            backdrop-filter: blur(2px);
                        `;

                        const loadingSpinner = document.createElement('div');
                        loadingSpinner.style.cssText = `
                            border: 4px solid #f3f3f3;
                            border-top: 4px solid #3498db;
                            border-radius: 50%;
                            width: 40px;
                            height: 40px;
                            animation: spin 1s linear infinite;
                            margin-bottom: 15px;
                        `;

                        const loadingText = document.createElement('div');
                        loadingText.textContent = message;
                        loadingText.style.fontSize = '16px';
                        loadingText.style.color = '#333';

                        // 添加CSS动画
                        const style = document.createElement('style');
                        style.textContent = `
                            @keyframes spin {
                                0% { transform: rotate(0deg); }
                                100% { transform: rotate(360deg); }
                            }
                        `;

                        loadingOverlay.appendChild(loadingSpinner);
                        loadingOverlay.appendChild(loadingText);
                        document.body.appendChild(loadingOverlay);
                        document.body.appendChild(style);
                    }
                },

                hide: function () {
                    loadingCount.value--;
                    if (loadingCount.value <= 0) {
                        loadingCount.value = 0;
                        const overlay = document.getElementById('loading-overlay');
                        if (overlay) {
                            overlay.remove();
                        }
                    }
                }
            };
        }

        // 创建全局加载管理器实例
        const loading = new LoadingManager();

        // 表单验证函数
        function validateForm() {
            let isValid = true;
            const errorMessages = [];

            // 验证标题
            const title = document.getElementById('item-title').value.trim();
            if (!title) {
                errorMessages.push(window.t ? window.t('steam.titleRequired') : '请输入标题');
                document.getElementById('item-title').classList.add('error');
                isValid = false;
            } else {
                document.getElementById('item-title').classList.remove('error');
            }

            // 验证内容文件夹
            const contentFolder = document.getElementById('content-folder').value.trim();
            if (!contentFolder) {
                errorMessages.push(window.t ? window.t('steam.contentFolderRequired') : '请指定内容文件夹');
                document.getElementById('content-folder').classList.add('error');
                isValid = false;
            } else {
                // 简单的路径格式验证
                if (/^[a-zA-Z]:\\/.test(contentFolder) || /^\//.test(contentFolder) || /^\.\.?[\\\/]/.test(contentFolder)) {
                    document.getElementById('content-folder').classList.remove('error');
                } else {
                    errorMessages.push(window.t ? window.t('invalidFolderFormat') : '内容文件夹路径格式不正确');
                    document.getElementById('content-folder').classList.add('error');
                    isValid = false;
                }
            }

            // 验证预览图片
            const previewImage = document.getElementById('preview-image').value.trim();
            if (!previewImage) {
                errorMessages.push(window.t ? window.t('steam.previewImageRequired') : '请上传预览图片');
                document.getElementById('preview-image').classList.add('error');
                isValid = false;
            } else {
                // 验证图片格式
                const imageExtRegex = /\.(jpg|jpeg|png)$/i;
                if (!imageExtRegex.test(previewImage)) {
                    errorMessages.push(window.t ? window.t('steam.previewImageFormat') : '预览图片格式必须为PNG、JPG或JPEG');
                    document.getElementById('preview-image').classList.add('error');
                    isValid = false;
                } else {
                    document.getElementById('preview-image').classList.remove('error');
                }
            }

            // 显示验证错误消息
            if (errorMessages.length > 0) {
                showMessage(errorMessages.join('\n'), 'error', 5000);
            }

            return isValid;
        }

        // 禁用/启用按钮函数
        function setButtonState(buttonElement, isDisabled) {
            if (buttonElement) {
                buttonElement.disabled = isDisabled;
                if (isDisabled) {
                    buttonElement.classList.add('button-disabled');
                } else {
                    buttonElement.classList.remove('button-disabled');
                }
            }
        }

        // 上传物品功能
        function uploadItem() {
            // 获取路径
            let contentFolder = document.getElementById('content-folder').value.trim();
            let previewImage = document.getElementById('preview-image').value.trim();

            if (!contentFolder) {
                showMessage(window.t ? window.t('steam.enterContentFolderPath') : '请输入内容文件夹路径', 'error');
                document.getElementById('content-folder').focus();
                return;
            }

            // 增强的路径规范化处理
            contentFolder = contentFolder.replace(/\\/g, '/');
            if (previewImage) {
                previewImage = previewImage.replace(/\\/g, '/');
            }

            // 显示路径验证通知
            showMessage(window.t ? window.t('steam.validatingFolderPath', { path: contentFolder }) : `正在验证文件夹路径: ${contentFolder}`, 'info');

            // 如果没有预览图片，仍然允许继续上传，后端会尝试自动查找或使用默认机制
            if (!previewImage) {
                showMessage(window.t ? window.t('steam.previewImageNotProvided') : '未提供预览图片，系统将尝试自动生成', 'warning');
            }

            // 验证表单
            if (!validateForm()) {
                return;
            }

            // 收集表单数据
            const title = document.getElementById('item-title')?.value.trim() || '';
            const description = document.getElementById('item-description')?.value.trim() || '';
            // 内容文件夹和预览图片路径已经在上面定义过了，不再重复定义
            const visibilitySelect = document.getElementById('visibility');
            const allowComments = document.getElementById('allow-comments')?.checked || false;

            // 收集标签
            let tags = [];
            const tagElements = document.querySelectorAll('#tags-container .tag');
            if (tagElements && tagElements.length > 0) {
                tags = Array.from(tagElements)
                    .filter(tag => tag && tag.textContent)
                    .map(tag => tag.textContent.replace('×', '').trim())
                    .filter(tag => tag); // 过滤空标签
            }

            // 转换可见性选项为数值
            let visibility = 0; // 默认公开
            if (visibilitySelect) {
                const value = visibilitySelect.value;
                if (value === 'friends') {
                    visibility = 1;
                } else if (value === 'private') {
                    visibility = 2;
                }
            }

            // 准备上传数据
            const uploadData = {
                title: title,
                description: description,
                content_folder: contentFolder,
                preview_image: previewImage,
                visibility: visibility,
                tags: tags,
                allow_comments: allowComments
            };

            // 获取上传按钮并禁用
            const uploadButton = document.querySelector('.upload-section button.button');
            let originalText = '';
            if (uploadButton) {
                originalText = uploadButton.textContent || '';
                uploadButton.textContent = window.t ? window.t('common.loading') : 'Uploading...';
                setButtonState(uploadButton, true);
            }

            // 显示上传中消息
            showMessage(window.t ? window.t('steam.preparingUpload') : '正在准备上传...', 'success', 0); // 0表示不自动关闭

            // 发送API请求
            fetch('/api/steam/workshop/publish', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(uploadData)
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP错误，状态码: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    // 恢复按钮状态
                    if (uploadButton) {
                        uploadButton.textContent = originalText;
                        setButtonState(uploadButton, false);
                    }

                    // 清除所有现有消息
                    const messageArea = document.getElementById('message-area');
                    if (messageArea) {
                        messageArea.innerHTML = '';
                    }

                    if (data.success) {
                        showMessage(window.t ? window.t('steam.uploadSuccess') : '上传成功！', 'success', 5000);

                        // 显示物品ID
                        if (data.published_file_id) {
                            showMessage(window.t ? window.t('steam.itemId', { id: data.published_file_id }) : `物品ID: ${data.published_file_id}`, 'success', 5000);

                            // 使用Steam overlay打开物品页面
                            try {
                                const published_id = data.published_file_id;
                                const url = `steam://url/CommunityFilePage/${published_id}`;

                                // 检查是否支持Steam overlay
                                if (window.steam && typeof window.steam.ActivateGameOverlayToWebPage === 'function') {
                                    window.steam.ActivateGameOverlayToWebPage(url);
                                } else {
                                    // 备选方案：尝试直接打开URL
                                    window.open(url);
                                }
                            } catch (e) {
                                console.error('无法打开Steam overlay:', e);
                            }
                        }

                        // 如果需要接受协议
                        if (data.needs_to_accept_agreement) {
                            showMessage(window.t ? window.t('steam.workshopAgreementRequired') : '请先同意Steam Workshop使用协议', 'warning', 8000);
                        }

                        // 清空表单
                        const formElements = [
                            { id: 'item-title', property: 'value', value: '' },
                            { id: 'item-description', property: 'value', value: '' },
                            { id: 'content-folder', property: 'value', value: '' },
                            { id: 'preview-image', property: 'value', value: '' },
                            { id: 'visibility', property: 'value', value: 'public' },
                            { id: 'allow-comments', property: 'checked', value: true }
                        ];

                        formElements.forEach(element => {
                            const el = document.getElementById(element.id);
                            if (el) {
                                el[element.property] = element.value;
                            }
                        });

                        // 清空标签
                        const tagsContainer = document.getElementById('tags-container');
                        if (tagsContainer) {
                            tagsContainer.innerHTML = '';
                        }

                        // 添加默认标签
                        addTag('模组');

                        // 显示成功提示和操作选项
                        setTimeout(() => {
                            const messageArea = document.getElementById('message-area');
                            const actionMessage = document.createElement('div');
                            actionMessage.className = 'success-message';
                            actionMessage.innerHTML = `
                            <span>${window.t ? window.t('steam.operationComplete') : 'Operation complete, you can:'}</span>
                            <button class="button button-sm" onclick="document.getElementById('item-title').focus()">${window.t ? window.t('steam.continueUpload') : 'Continue Uploading'}</button>
                            <button class="button button-sm" onclick="toggleUploadSection()">${window.t ? window.t('steam.hideUploadSection') : 'Hide Upload Section'}</button>
                            <span class="message-close" onclick="this.parentElement.remove()">×</span>
                        `;
                            messageArea.appendChild(actionMessage);
                        }, 1000);
                    } else {
                        showMessage(window.t ? window.t('steam.uploadError', { error: data.error || (window.t ? window.t('common.unknownError') : '未知错误') }) : `上传失败: ${data.error || '未知错误'}`, 'error', 8000);
                        if (data.message) {
                            showMessage(window.t ? window.t('steam.uploadWarning', { message: data.message }) : `警告: ${data.message}`, 'warning', 8000);
                        }

                        // 提供重试建议
                        setTimeout(() => {
                            const retryButton = document.createElement('button');
                            retryButton.className = 'button button-sm';
                            retryButton.textContent = '重试上传';
                            retryButton.onclick = uploadItem;

                            const messageArea = document.getElementById('message-area');
                            const retryMessage = document.createElement('div');
                            retryMessage.className = 'error-message';
                            retryMessage.innerHTML = `<span>${window.t ? window.t('steam.retryPrompt') : 'Would you like to retry the upload?'}</span>
                            <button class="button button-sm" onclick="uploadItem()">${window.t ? window.t('steam.retryUpload') : 'Retry Upload'}</button>
                            <span class="message-close" onclick="this.parentElement.remove()">×</span>`;
                            messageArea.appendChild(retryMessage);
                        }, 2000);
                    }
                })
                .catch(error => {
                    console.error('上传失败:', error);

                    // 恢复按钮状态
                    if (uploadButton) {
                        uploadButton.textContent = originalText;
                        setButtonState(uploadButton, false);
                    }

                    // 清除所有现有消息
                    const messageArea = document.getElementById('message-area');
                    if (messageArea) {
                        messageArea.innerHTML = '';
                    }

                    let errorMessage = window.t ? window.t('steam.uploadGeneralError') : '上传失败';

                    // 根据错误类型提供更具体的提示
                    if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                        errorMessage = window.t ? window.t('steam.uploadNetworkError') : '网络错误，请检查您的连接';
                        showMessage(window.t ? window.t('steam.uploadErrorFormat', { message: errorMessage }) : errorMessage, 'error', 8000);
                        showMessage(window.t ? window.t('steam.checkNetworkConnection') : '请检查您的网络连接', 'warning', 8000);
                    } else if (error.message.includes('HTTP错误')) {
                        errorMessage = window.t ? window.t('steam.uploadHttpError', { error: error.message }) : `HTTP错误: ${error.message}`;
                        showMessage(window.t ? window.t('steam.uploadErrorFormat', { message: errorMessage }) : errorMessage, 'error', 8000);
                        showMessage(window.t ? window.t('steam.serverProblem', { message: window.t ? window.t('common.tryAgainLater') : '请稍后重试' }) : '服务器问题，请稍后重试', 'warning', 8000);
                    } else {
                        showMessage(window.t ? window.t('steam.uploadErrorFormat', { message: window.t ? window.t('steam.uploadErrorWithMessage', { error: error.message }) : `错误: ${error.message}` }) : `错误: ${error.message}`, 'error', 8000);
                    }
                });
        }

        // 分页相关变量
        let allSubscriptions = []; // 存储所有订阅物品
        let currentPage = 1;
        let itemsPerPage = 10;
        let totalPages = 1;
        let currentSortField = 'timeAdded'; // 默认按添加时间排序
        let currentSortOrder = 'desc'; // 默认降序

        // 加载订阅物品
        function loadSubscriptions() {
            const subscriptionsList = document.getElementById('subscriptions-list');
            subscriptionsList.innerHTML = `<div class="empty-state"><p>${window.t ? window.t('steam.loadingSubscriptions') : '正在加载您的订阅物品...'}</p></div>`;

            // 调用后端API获取订阅物品列表
            fetch('/api/steam/workshop/subscribed-items')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (!data.success) {
                        subscriptionsList.innerHTML = `<div class="empty-state"><p>${window.t ? window.t('steam.fetchFailed') : 'Failed to fetch subscribed items'}: ${data.error || (window.t ? window.t('common.unknownError') : 'Unknown error')}</p></div>`;
                        // 如果有消息提示，显示给用户
                        if (data.message) {
                            showMessage(data.message, 'error');
                        }
                        updatePagination(); // 更新分页状态
                        return;
                    }

                    // 保存所有订阅物品到全局变量
                    allSubscriptions = data.items || [];

                    // 应用排序（从下拉框获取排序方式）
                    const sortSelect = document.getElementById('sort-subscription');
                    if (sortSelect) {
                        const [field, order] = sortSelect.value.split('_');
                        sortSubscriptions(field, order);
                    } else {
                        // 默认按日期降序排序
                        sortSubscriptions('date', 'desc');
                    }

                    // 计算总页数
                    totalPages = Math.ceil(allSubscriptions.length / itemsPerPage);
                    if (totalPages < 1) totalPages = 1;
                    if (currentPage > totalPages) currentPage = totalPages;

                    // 显示当前页的数据
                    renderSubscriptionsPage();

                    // 更新分页UI
                    updatePagination();
                })
                .catch(error => {
                    console.error('获取订阅物品失败:', error);
                    subscriptionsList.innerHTML = `<div class="empty-state"><p>${window.t ? window.t('steam.fetchFailed') : '获取订阅物品失败'}: ${error.message}</p></div>`;
                    showMessage(window.t ? window.t('steam.cannotConnectToServer') : '无法连接到服务器，请稍后重试', 'error');
                });
        }

        // 渲染当前页的订阅物品
        function renderSubscriptionsPage() {
            const subscriptionsList = document.getElementById('subscriptions-list');

            if (allSubscriptions.length === 0) {
                subscriptionsList.innerHTML = `<div class="empty-state"><p>${window.t ? window.t('steam.noSubscriptions') : 'You haven\'t subscribed to any workshop items yet'}</p></div>`;
                return;
            }

            // 计算当前页的数据范围
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const currentItems = allSubscriptions.slice(startIndex, endIndex);

            // 生成卡片HTML
            subscriptionsList.innerHTML = currentItems.map(item => {
                // 格式化物品数据为前端所需格式
                // 确保publishedFileId转换为字符串，避免类型错误
                const formattedItem = {
                    id: String(item.publishedFileId),
                    name: item.title || `${window.t ? window.t('steam.unknownItem') : '未知物品'}_${String(item.publishedFileId)}`,
                    author: item.steamIDOwner ? String(item.steamIDOwner) : (window.t ? window.t('steam.unknownAuthor') : '未知作者'), // 暂时使用SteamID作为作者名
                    subscribedDate: item.timeAdded ? new Date(item.timeAdded * 1000).toLocaleDateString() : (window.t ? window.t('steam.unknownDate') : '未知日期'),
                    lastUpdated: item.timeUpdated ? new Date(item.timeUpdated * 1000).toLocaleDateString() : (window.t ? window.t('steam.unknownDate') : '未知日期'),
                    size: formatFileSize(item.fileSizeOnDisk || item.fileSize || 0),
                    previewUrl: item.previewUrl || item.previewImageUrl || '../static/icons/Steam_icon_logo.png',
                    state: item.state || {},
                    // 添加安装路径信息
                    installedFolder: item.installedFolder || '',
                    description: item.description || '暂无描述',
                    timeAdded: item.timeAdded || 0,
                    fileSize: item.fileSizeOnDisk || item.fileSize || 0
                };

                // 确定状态类和文本
                let statusClass = 'status-subscribed';
                let statusText = window.t ? window.t('steam.status.subscribed') : '已订阅';

                if (formattedItem.state.downloading) {
                    statusClass = 'status-downloading';
                    statusText = window.t ? window.t('steam.status.downloading') : '下载中';
                } else if (formattedItem.state.needsUpdate) {
                    statusClass = 'status-needs-update';
                    statusText = window.t ? window.t('steam.status.needsUpdate') : '需要更新';
                } else if (formattedItem.state.installed) {
                    statusClass = 'status-installed';
                    statusText = window.t ? window.t('steam.status.installed') : '已安装';
                }

                return `
                    <div class="workshop-card">
                        <div class="card-header">
                            <img src="${formattedItem.installedFolder ? `/api/steam/proxy-image?image_path=${encodeURIComponent(formattedItem.installedFolder + '/preview.png')}` : `/api/steam/proxy-image?image_path=${encodeURIComponent(formattedItem.previewUrl)}`}" alt="${formattedItem.name}" class="card-image">
                            <div class="status-badge ${statusClass}">${statusText}</div>
                        </div>
                        <div class="card-content">
                            <h3 class="card-title">${formattedItem.name}</h3>
                            <div class="author-info">
                                <div class="author-avatar">${formattedItem.author.substring(0, 2).toUpperCase()}</div>
                                <span>${window.t ? window.t('steam.author') : '作者'}: ${formattedItem.author}</span>
                            </div>
                            <div class="card-info-grid">
                                <div class="card-info-item"><span class="info-label">${window.t ? window.t('steam.subscribed_date') : '订阅日期'}:</span> <span class="info-value">${formattedItem.subscribedDate}</span></div>
                                <div class="card-info-item"><span class="info-label">${window.t ? window.t('steam.last_updated') : '最后更新'}:</span> <span class="info-value">${formattedItem.lastUpdated}</span></div>
                                <div class="card-info-item"><span class="info-label">${window.t ? window.t('steam.size') : '大小'}:</span> <span class="info-value">${formattedItem.size}</span></div>
                            </div>
                            ${formattedItem.state && formattedItem.state.downloading && item.downloadProgress ?
                        `<div class="download-progress">
                                    <div class="progress-bar">
                                        <div class="progress-fill" style="width: ${item.downloadProgress.percentage}%">
                                            ${item.downloadProgress.percentage.toFixed(1)}%
                                        </div>
                                    </div>
                                </div>` : ''
                    }
                            <div class="card-actions">
                                     <!-- 查看详情下次再加，一时半会儿搞不定 -->
                                <button class="button button-danger" onclick="unsubscribeItem('${formattedItem.id}', '${formattedItem.name}')">${window.t ? window.t('steam.unsubscribe') : '取消订阅'}</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // 更新分页控件
        function updatePagination() {
            const pagination = document.querySelector('.pagination');
            if (!pagination) return;

            const prevBtn = pagination.querySelector('button:first-child');
            const nextBtn = pagination.querySelector('button:last-child');
            const pageInfo = pagination.querySelector('span');

            // 更新页码信息
            if (pageInfo) {
                pageInfo.textContent = window.t ? window.t('steam.pagination', { currentPage: currentPage, totalPages: totalPages }) : `${currentPage} / ${totalPages}`;
            }

            // 更新上一页按钮状态
            if (prevBtn) {
                prevBtn.disabled = currentPage <= 1;
            }

            // 更新下一页按钮状态
            if (nextBtn) {
                nextBtn.disabled = currentPage >= totalPages;
            }
        }

        // 前往上一页
        function goToPrevPage() {
            if (currentPage > 1) {
                currentPage--;
                renderSubscriptionsPage();
                updatePagination();
            }
        }

        // 前往下一页
        function goToNextPage() {
            if (currentPage < totalPages) {
                currentPage++;
                renderSubscriptionsPage();
                updatePagination();
            }
        }

        // 排序订阅物品
        function sortSubscriptions(field, order) {
            if (allSubscriptions.length <= 1) return;

            allSubscriptions.sort((a, b) => {
                let aValue, bValue;

                // 根据不同字段获取对应的值
                switch (field) {
                    case 'name':
                        aValue = (a.title || String(a.publishedFileId || '')).toLowerCase();
                        bValue = (b.title || String(b.publishedFileId || '')).toLowerCase();
                        break;
                    case 'date':
                        aValue = a.timeAdded || 0;
                        bValue = b.timeAdded || 0;
                        break;
                    case 'size':
                        aValue = a.fileSizeOnDisk || a.fileSize || 0;
                        bValue = b.fileSizeOnDisk || b.fileSize || 0;
                        break;
                    case 'update':
                        aValue = a.timeUpdated || 0;
                        bValue = b.timeUpdated || 0;
                        break;
                    default:
                        // 默认按名称排序
                        aValue = (a.title || String(a.publishedFileId || '')).toLowerCase();
                        bValue = (b.title || String(b.publishedFileId || '')).toLowerCase();
                }

                // 处理空值
                if (aValue === undefined || aValue === null) aValue = '';
                if (bValue === undefined || bValue === null) bValue = '';

                // 字符串比较
                if (typeof aValue === 'string') {
                    return order === 'asc' ?
                        aValue.localeCompare(bValue) :
                        bValue.localeCompare(aValue);
                }
                // 数字比较
                return order === 'asc' ?
                    (aValue - bValue) :
                    (bValue - aValue);
            });
        }

        // 应用排序
        function applySort(sortValue) {
            // 解析排序值
            const [field, order] = sortValue.split('_');

            // 重置到第一页
            currentPage = 1;

            // 应用排序
            sortSubscriptions(field, order);

            // 重新渲染页面
            renderSubscriptionsPage();

            // 更新分页
            updatePagination();
        }

        // 过滤订阅物品
        function filterSubscriptions(searchTerm) {
            // 简单实现过滤功能
            searchTerm = searchTerm.toLowerCase().trim();

            // 保存原始数据
            if (window.originalSubscriptions === undefined) {
                window.originalSubscriptions = [...allSubscriptions];
            }

            // 如果搜索词为空，恢复原始数据
            if (!searchTerm) {
                if (window.originalSubscriptions) {
                    allSubscriptions = [...window.originalSubscriptions];
                }
                // 重新应用当前排序
                const sortSelect = document.getElementById('sort-subscription');
                if (sortSelect) {
                    applySort(sortSelect.value);
                }
                return;
            }

            // 过滤物品
            let itemsToFilter = window.originalSubscriptions || [...allSubscriptions];
            const filteredItems = itemsToFilter.filter(item => {
                const title = (item.title || '').toLowerCase();
                return title.includes(searchTerm);
            });

            allSubscriptions = filteredItems;

            // 重新计算分页
            totalPages = Math.ceil(allSubscriptions.length / itemsPerPage);
            if (totalPages < 1) totalPages = 1;
            if (currentPage > totalPages) currentPage = totalPages;

            // 渲染过滤后的结果
            renderSubscriptionsPage();
            updatePagination();
        }

        // 格式化文件大小
        function formatFileSize(bytes) {
            if (bytes === 0 || bytes === undefined) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // 获取状态文本
        function getStatusText(state) {
            if (state.downloading) {
                return window.t ? window.t('steam.status.downloading') : '下载中';
            } else if (state.needsUpdate) {
                return window.t ? window.t('steam.status.needsUpdate') : '需要更新';
            } else if (state.installed) {
                return window.t ? window.t('steam.status.installed') : '已安装';
            } else if (state.subscribed) {
                return window.t ? window.t('steam.status.subscribed') : '已订阅';
            } else {
                return window.t ? window.t('steam.status.unknown') : '未知';
            }
        }

        // 打开模态框
        function openModal() {
            const modal = document.getElementById('itemDetailsModal');
            modal.style.display = 'flex';
            // 阻止页面滚动
            document.body.style.overflow = 'hidden';
        }

        // 关闭模态框
        function closeModal() {
            const modal = document.getElementById('itemDetailsModal');
            modal.style.display = 'none';
            // 恢复页面滚动
            document.body.style.overflow = 'auto';
        }

        // 点击模态框外部关闭
        function closeModalOnOutsideClick(event) {
            const modal = document.getElementById('itemDetailsModal');
            if (event.target === modal) {
                closeModal();
            }
        }


        // 查看物品详情
function viewItemDetails(itemId) {
    // 显示加载消息
    showMessage(`正在加载物品ID: ${itemId} 的详细信息...`, 'success');
    
    // 调用后端API获取物品详情
    fetch(`/api/steam/workshop/item/${itemId}`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            if (!data.success) {
                showMessage(`获取物品详情失败: ${data.error || '未知错误'}`, 'error');
                return;
            }
            
            const item = data.item;
            const formattedItem = {
                id: item.publishedFileId.toString(),
                name: item.title,
                author: item.steamIDOwner.toString(),
                subscribedDate: new Date(item.timeAdded * 1000).toLocaleDateString(),
                lastUpdated: new Date(item.timeUpdated * 1000).toLocaleDateString(),
                size: formatFileSize(item.fileSize),
                previewUrl: item.previewImageUrl || '../static/icons/Steam_icon_logo.png',
                description: item.description || '暂无描述',
                downloadCount: 'N/A',
                rating: 'N/A',
                tags: ['模组'], // 默认标签，实际应用中应该从API获取
                state: item.state || {} // 添加state属性，确保后续代码可以正常访问
            };
            
            // 确定状态类和文本
            let statusClass = 'status-subscribed';
            let statusText = getStatusText(formattedItem.state || {});
            
            if (formattedItem.state && formattedItem.state.downloading) {
                statusClass = 'status-downloading';
            } else if (formattedItem.state && formattedItem.state.needsUpdate) {
                statusClass = 'status-needs-update';
            } else if (formattedItem.state && formattedItem.state.installed) {
                statusClass = 'status-installed';
            }
            
            // 获取作者头像（使用首字母作为占位符）
            const authorInitial = formattedItem.author.substring(0, 2).toUpperCase();
            
            // 更新模态框内容
            document.getElementById('modalTitle').textContent = formattedItem.name;
            
            const detailContent = document.getElementById('itemDetailContent');
            detailContent.innerHTML = `
                <img src="${formattedItem.installedFolder ? `/api/steam/proxy-image?image_path=${encodeURIComponent(formattedItem.installedFolder + '/preview.png')}` : `/api/steam/proxy-image?image_path=${encodeURIComponent(formattedItem.previewUrl)}`}" alt="${formattedItem.name}" class="item-preview-large">
                
                <div class="item-info-grid">
                    <p class="item-info-item">
                        <span class="item-info-label">${window.t ? window.t('steam.author') : '作者'}:</span>
                        <div class="author-info">
                            <div class="author-avatar">${authorInitial}</div>
                            <span>${formattedItem.author}</span>
                        </div>
                    </p>
                    <p class="item-info-item"><span class="item-info-label">${window.t ? window.t('steam.subscribed_date') : '订阅日期'}:</span> ${formattedItem.subscribedDate}</p>
                    <p class="item-info-item"><span class="item-info-label">${window.t ? window.t('steam.last_updated') : '最后更新'}:</span> ${formattedItem.lastUpdated}</p>
                    <p class="item-info-item"><span class="item-info-label">${window.t ? window.t('steam.size') : '大小'}:</span> ${formattedItem.size}</p>
                    <p class="item-info-item">
                        <span class="item-info-label">${window.t ? window.t('steam.status_label') : '状态'}:</span>
                        <span class="status-badge ${statusClass}">${statusText}</span>
                    </p>
                    <p class="item-info-item"><span class="item-info-label">${window.t ? window.t('steam.download_count') : '下载次数'}:</span> ${formattedItem.downloadCount}</p>
                    ${formattedItem.state && formattedItem.state.downloading && item.downloadProgress ?
                            `<p class="item-info-item" style="grid-column: span 2;">
                            <div class="download-progress">
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: ${item.downloadProgress.percentage}%">
                                        ${item.downloadProgress.percentage.toFixed(1)}%
                                    </div>
                                </div>
                            </div>
                        </p>` : ''
                        }
                </div>
                
                <div>
                    <h4>${window.t ? window.t('steam.tags') : '标签'}</h4>
                    <div class="tags-container">
                        ${formattedItem.tags.map(tag => `
                            <div class="tag">${tag}</div>
                        `).join('')}
                    </div>
                </div>
                
                <div>
                    <h4>${window.t ? window.t('steam.description') : '描述'}</h4>
                    <p class="item-description">${formattedItem.description}</p>
                </div>
            `;

                    // 打开模态框
                    openModal();
                })
                .catch(error => {
                    console.error('获取物品详情失败:', error);
                    showMessage(window.t ? window.t('steam.cannotLoadItemDetails') : '无法加载物品详情', 'error');
                });
        }

        // 取消订阅功能
        function unsubscribeItem(itemId, itemName) {
            if (confirm(window.t ? window.t('steam.unsubscribeConfirm', { name: itemName }) : `确定要取消订阅 "${itemName}" 吗？`)) {
                // 查找当前卡片并添加移除动画效果
                const cards = document.querySelectorAll('.workshop-card');
                for (let card of cards) {
                    const cardTitle = card.querySelector('.card-title').textContent;
                    if (cardTitle === itemName) {
                        // 添加淡出效果
                        card.style.opacity = '0.6';
                        card.style.transform = 'scale(0.95)';
                        break;
                    }
                }

                // 调用后端API执行取消订阅操作
                showMessage(window.t ? window.t('steam.cancellingSubscription', { name: itemName }) : `Cancelling subscription to "${itemName}"...`, 'success');

                fetch('/api/steam/workshop/unsubscribe', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ item_id: itemId })
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        // 显示异步操作状态
                        let statusMessage = window.t ? window.t('steam.unsubscribeAccepted', {name: itemName}) : `已接受取消订阅: ${itemName}`;
                        if (data.status === 'accepted') {
                            statusMessage = window.t ? window.t('steam.unsubscribeProcessing', {name: itemName}) : `正在处理取消订阅: ${itemName}`;
                        }
                        showMessage(statusMessage, 'success');
                        
                        // 获取并删除与该物品相关的角色卡
                        async function deleteRelatedCharacterCards() {
                            try {
                                // 首先获取所有已添加的角色卡
                                const cardsResponse = await fetch('/api/characters/');
                                if (!cardsResponse.ok) throw new Error('获取角色卡列表失败');
                                
                                const cards = await cardsResponse.json();
                                let hasDeletionFailed = false;
                                
                                // 查找与当前物品名称相关的角色卡
                                for (const cardName in cards.猫娘 || {}) {
                                    const card = cards.猫娘[cardName];
                                    // 检查角色卡名称是否包含物品名称
                                    if (cardName.includes(itemName) || (card.名称 && card.名称.includes(itemName))) {
                                        // 删除相关角色卡
                                        const deleteUrl = `/api/characters/catgirl/${encodeURIComponent(cardName)}`;
                                        const deleteResponse = await fetch(deleteUrl, {
                                            method: 'DELETE',
                                            headers: {
                                                'Content-Type': 'application/json'
                                            }
                                        });
                                        
                                        if (deleteResponse.ok) {
                                            console.log(`成功删除角色卡: ${cardName}`);
                                        } else {
                                            const deleteData = await deleteResponse.json();
                                            console.error(`删除角色卡失败: ${cardName}, 错误: ${deleteData.error}`);
                                            
                                            // 检查是否是"当前正在使用的猫娘"错误
                                            if (deleteData.error && deleteData.error.includes('当前正在使用的猫娘')) {
                                                hasDeletionFailed = true;
                                                showMessage(`无法删除角色卡 "${cardName}": ${deleteData.error}`, 'warning');
                                            } else {
                                                // 其他错误类型
                                                showMessage(`删除角色卡 "${cardName}" 失败: ${deleteData.error || '未知错误'}`, 'error');
                                            }
                                        }
                                    }
                                }
                                
                                if (hasDeletionFailed) {
                                    showMessage('部分角色卡删除失败，可能是因为它们正在被使用中', 'warning');
                                }
                            } catch (error) {
                                console.error('处理角色卡删除时出错:', error);
                                showMessage('删除角色卡时发生错误: ' + error.message, 'error');
                            }
                        }
                        
                        // 调用删除相关角色卡的函数
                        deleteRelatedCharacterCards().then(() => {
                            // 删除完成后重新加载角色卡列表
                            setTimeout(() => {
                                loadCharacterCards();
                            }, 500);
                        });
                        
                        // 立即重新加载订阅列表
                        loadSubscriptions();
                        
                        // 添加短暂延迟后再次刷新，确保获取最新状态
                        setTimeout(() => {
                            loadSubscriptions();
                            showMessage(window.t ? window.t('steam.subscriptionsUpdated') : '订阅更新完成', 'success');
                        }, 1000);
                        
                    } else {
                        const errorMsg = data.error || (window.t ? window.t('common.unknownError') : '未知错误');
                        showMessage(window.t ? window.t('steam.unsubscribeFailed') : `取消订阅失败: ${errorMsg}`, 'error');
                        // 如果有消息提示，显示给用户
                        if (data.message) {
                            showMessage(data.message, 'warning');
                        }
                    }
                })
                .catch(error => {
                    console.error('取消订阅失败:', error);
                    showMessage(window.t ? window.t('steam.unsubscribeError') : '取消订阅失败', 'error');
                });
            }
        }
        
        // 全局变量：存储所有可用模型信息
        let availableModels = [];
        
        // 全局Set：用于跟踪已处理的音频文件，防止重复注册
        // 使用localStorage持久化存储，避免页面刷新后重复扫描
        let processedAudioFiles = new Set();
        
        // 页面加载时从localStorage恢复已处理的音频文件列表
        function loadProcessedAudioFiles() {
            try {
                const stored = localStorage.getItem('neko_processed_audio_files');
                if (stored) {
                    const files = JSON.parse(stored);
                    processedAudioFiles = new Set(files);
                    console.log(`已从localStorage恢复 ${processedAudioFiles.size} 个已处理音频文件记录`);
                }
            } catch (error) {
                console.error('从localStorage加载已处理音频文件失败:', error);
                processedAudioFiles = new Set();
            }
        }
        
        // 保存已处理的音频文件列表到localStorage
        function saveProcessedAudioFiles() {
            try {
                const files = Array.from(processedAudioFiles);
                localStorage.setItem('neko_processed_audio_files', JSON.stringify(files));
            } catch (error) {
                console.error('保存已处理音频文件到localStorage失败:', error);
            }
        }
        
        // 页面加载时初始化
        loadProcessedAudioFiles();
        
        // 自动扫描创意工坊角色卡并添加到系统
        async function autoScanAndAddWorkshopCharacterCards() {
            try {
                console.log('开始自动扫描创意工坊角色卡...');
                
                // 1. 获取所有订阅的创意工坊物品
                const subscribedResponse = await fetch('/api/steam/workshop/subscribed-items');
                const subscribedResult = await subscribedResponse.json();
                
                if (!subscribedResult.success) {
                    console.error('获取订阅物品失败:', subscribedResult.error);
                    return;
                }
                
                const subscribedItems = subscribedResult.items;
                console.log(`找到 ${subscribedItems.length} 个订阅物品`);
                
                let addedCount = 0;
                
                // 2. 遍历所有已安装的物品
                for (const item of subscribedItems) {
                    if (!item.installedFolder) {
                        console.log(`物品 ${item.title} (${item.publishedFileId}) 未安装，跳过`);
                        continue;
                    }
                    
                    const itemId = item.publishedFileId;
                    const folderPath = item.installedFolder;
                    
                    console.log(`检查物品 ${item.title} (${itemId}) 的安装目录: ${folderPath}`);
                    
                    // 3. 使用新的API扫描目录中所有.chara.json文件
                    try {
                        const listResponse = await fetch(`/api/steam/workshop/list-chara-files?directory=${encodeURIComponent(folderPath)}`);
                        const listResult = await listResponse.json();
                        
                        if (listResult.success && listResult.files.length > 0) {
                            console.log(`在目录 ${folderPath} 中找到 ${listResult.files.length} 个角色卡文件:`);
                            
                            // 4. 遍历所有找到的.chara.json文件
                            for (const file of listResult.files) {
                                console.log(`  - ${file.name}`);
                                await scanCharaFile(file.path, itemId, item.title);
                            }
                        } else {
                            console.log(`在目录 ${folderPath} 中未找到角色卡文件`);
                        }
                    } catch (listError) {
                        console.error(`扫描目录 ${folderPath} 中的角色卡文件失败:`, listError);
                    }
                    
                    // 5. 使用新的API扫描目录中所有音频文件(.mp3, .wav)
                    try {
                        const audioListResponse = await fetch(`/api/steam/workshop/list-audio-files?directory=${encodeURIComponent(folderPath)}`);
                        const audioListResult = await audioListResponse.json();
                        
                        if (audioListResult.success && audioListResult.files.length > 0) {
                            console.log(`在目录 ${folderPath} 中找到 ${audioListResult.files.length} 个音频文件:`);
                            
                            // 6. 遍历所有找到的音频文件
                            for (const audioFile of audioListResult.files) {
                                console.log(`  - ${audioFile.name}`);
                                await scanAudioFile(audioFile.path, audioFile.prefix, itemId, item.title);
                            }
                        } else {
                            console.log(`在目录 ${folderPath} 中未找到音频文件`);
                        }
                    } catch (audioListError) {
                        console.error(`扫描目录 ${folderPath} 中的音频文件失败:`, audioListError);
                    }
                }
                
                console.log('自动扫描创意工坊角色卡完成');
                
            } catch (error) {
                console.error('自动扫描和添加角色卡失败:', error);
            }
        }
        
        // 扫描单个音频文件并调用voice_clone API
        async function scanAudioFile(filePath, prefix, itemId, itemTitle) {
            // 检查文件是否已处理
            if (processedAudioFiles.has(filePath)) {
                console.log(`音频文件 ${filePath} 已处理，跳过注册`);
                return;
            }
            
            try {
                // 使用现有的read-file API读取文件内容
                const readResponse = await fetch(`/api/steam/workshop/read-file?path=${encodeURIComponent(filePath)}`);
                const readResult = await readResponse.json();
                
                if (readResult.success) {
                    // 将base64内容转换为Blob
                    const base64ToBlob = (base64, mimeType) => {
                        const byteCharacters = atob(base64);
                        const byteNumbers = new Array(byteCharacters.length);
                        for (let i = 0; i < byteCharacters.length; i++) {
                            byteNumbers[i] = byteCharacters.charCodeAt(i);
                        }
                        const byteArray = new Uint8Array(byteNumbers);
                        return new Blob([byteArray], {type: mimeType});
                    };
                    
                    // 确定文件类型
                    const fileExtension = filePath.split('.').pop().toLowerCase();
                    const mimeType = fileExtension === 'mp3' ? 'audio/mpeg' : 'audio/wav';
                    
                    // 创建Blob对象
                    const blob = base64ToBlob(readResult.content, mimeType);
                    
                    // 创建FormData对象
                    const formData = new FormData();
                    formData.append('file', blob, filePath.split('\\').pop());
                    formData.append('prefix', prefix);
                    
                    // 调用voice_clone API
                    const cloneResponse = await fetch('/api/characters/voice_clone', {
                        method: 'POST',
                        body: formData
                    });
                    
                    const cloneResult = await cloneResponse.json();
                    
                    if (cloneResponse.ok) {
                        console.log(`成功克隆音频文件 ${filePath}:`, cloneResult);
                        // 标记文件为已处理
                        processedAudioFiles.add(filePath);
                        // 保存到localStorage以持久化
                        saveProcessedAudioFiles();
                    } else {
                        console.error(`克隆音频文件 ${filePath} 失败:`, cloneResult.error);
                    }
                } else {
                    console.error(`读取音频文件 ${filePath} 失败:`, readResult.error);
                }
            } catch (error) {
                console.error(`处理音频文件 ${filePath} 时出错:`, error);
            }
        }
        
        // 扫描单个角色卡文件
        async function scanCharaFile(filePath, itemId, itemTitle) {
            try {
                // 使用新的read-file API读取文件内容
                const readResponse = await fetch(`/api/steam/workshop/read-file?path=${encodeURIComponent(filePath)}`);
                const readResult = await readResponse.json();
                
                if (readResult.success) {
                    // 解析文件内容
                    const charaData = JSON.parse(readResult.content);
                    
                    // 验证角色卡数据是否有效，兼容中英文字段名
                    if (!charaData['档案名'] && !charaData['名称'] && !charaData['name']) {
                        console.log(`角色卡 ${filePath} 缺少名称字段，跳过`);
                        return;
                    }
                    
                    // 转换为符合catgirl API格式的数据，兼容中英文字段名
                    const catgirlFormat = {
                        '档案名': charaData['档案名'] || charaData['name'] || '',
                        '名称': charaData['名称'] || charaData['name'] || '',
                        '描述': charaData['描述'] || charaData['description'] || '',
                        '标签': charaData['标签'] || charaData['tags'] || [],
                        '原始数据': charaData,
                        '文件路径': filePath,
                        '创意工坊物品ID': itemId
                    };
                    
                    // 添加其他字段，避免重复处理已存在的字段
                    const processedKeys = ['档案名', '名称', '描述', '标签', '原始数据', '文件路径', '创意工坊物品ID'];
                    for (const [key, value] of Object.entries(charaData)) {
                        // 跳过已处理的关键字段和空值
                        if (!processedKeys.includes(key) && key !== 'name' && key !== 'description' && key !== 'tags' && value) {
                            catgirlFormat[key] = value;
                        }
                    }
                    
                    // 调用catgirl API添加到系统
                    const addResponse = await fetch('/api/characters/catgirl', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(catgirlFormat)
                    });
                    
                    const addResult = await addResponse.json();
                    // 获取角色卡名称（兼容中英文字段）
                    const charaName = catgirlFormat['档案名'] || charaData.name || '未知名称';
                    
                    if (addResult.success) {
                        console.log(`成功添加角色卡: ${charaName} (来自物品: ${itemTitle})`);
                        // 延迟刷新角色卡列表，确保数据已保存
                        setTimeout(() => {
                            loadCharacterCards();
                        }, 500);
                    } else {
                        const errorMsg = `角色卡 ${charaName} 已存在或添加失败: ${addResult.error}`;
                        console.log(errorMsg);
                        showMessage(errorMsg, 'warning');
                    }
                } else if (readResult.error !== '文件不存在') {
                    console.error(`读取角色卡文件 ${filePath} 失败:`, readResult.error);
                }
            } catch (error) {
                if (error.message !== 'Failed to fetch') {
                    console.error(`处理角色卡文件 ${filePath} 时出错:`, error);
                }
            }
        }

        // 初始化页面
        window.onload = function() {
            // 检查是否需要切换到特定标签页
            const lastActiveTab = localStorage.getItem('lastActiveTab');
            if (lastActiveTab) {
                switchTab(lastActiveTab);
                // 清除存储的标签页信息
                localStorage.removeItem('lastActiveTab');
            }
            
            // 初始化时添加默认的Character标签
            addCharacterCardTag('character-card', window.t ? window.t('steam.defaultTagCharacter') : 'Character');
            
            // 初始化i18n文本
            if (document.getElementById('loading-text')) {
                document.getElementById('loading-text').textContent = window.t ? window.t('steam.loadingSubscriptions') : '正在加载您的订阅物品...';
            }
            if (document.getElementById('reload-button')) {
                document.getElementById('reload-button').textContent = window.t ? window.t('steam.reload') : '重新加载';
            }
            if (document.getElementById('search-subscription')) {
                document.getElementById('search-subscription').placeholder = window.t ? window.t('steam.searchPlaceholder') : '搜索订阅内容...';
            }

            // 页面加载时自动加载订阅内容
            loadSubscriptions();

            // 页面加载时自动扫描本地物品
            scanLocalItems();
            
            // 页面加载时自动加载角色卡
            loadCharacterCards();
            
            // 页面加载时自动扫描创意工坊角色卡并添加到系统
            autoScanAndAddWorkshopCharacterCards();
            
            // 初始化模型选择功能
            initModelSelection();
            
            // 添加模型上传文件选择事件监听
            const modelUploadInput = document.getElementById('model-upload-input');
            if (modelUploadInput) {
                modelUploadInput.addEventListener('change', handleModelUpload);
            }
        };
        
        // 角色卡相关函数
        
        // 加载角色卡列表
        // 加载角色卡数据
        async function loadCharacterData() {
            try {
                const resp = await fetch('/api/characters/');
                return await resp.json();
            } catch (error) {
                console.error('加载角色数据失败:', error);
                showMessage('加载角色数据失败', 'error');
                return null;
            }
        }

        // 全局变量：角色卡列表
        let globalCharacterCards = [];
        
        // 全局变量：当前编辑的角色卡ID
        let currentEditCardId = null;
        
        // 全局变量：当前打开的角色卡ID（用于模态框操作）
        let currentCharacterCardId = null;
        
        // 全局变量：当前编辑的角色卡原始键名（用于API请求）
        let currentEditCardOriginalName = null;
        
        // 加载角色卡列表
        async function loadCharacterCards() {
            // 显示加载状态
            const characterCardsList = document.getElementById('character-cards-list');
            if (characterCardsList) {
                characterCardsList.innerHTML = `
                    <div class="loading-state">
                        <p>正在加载角色卡...</p>
                    </div>
                `;
            }

            // 获取角色数据
            const characterData = await loadCharacterData();
            if (!characterData) return;

            // 调用scanModels()获取可用模型列表
            await scanModels();

            // 转换角色数据为角色卡格式
            const characterCards = [];
            let idCounter = 1;

            // 只处理猫娘数据，忽略其他角色类型（包括主人）
            const catgirls = characterData['猫娘'] || {};
            for (const [name, data] of Object.entries(catgirls)) {
                // 兼容实际的数据结构 - 使用可用字段创建角色卡
                // 只从description或角色卡描述字段获取描述信息
                let description = '暂无描述';
                if (data['description']) {
                    description = data['description'];
                } else if (data['描述']) {
                    description = data['描述'];
                } else if (data['角色卡描述']) {
                    description = data['角色卡描述'];
                }

                // 只从关键词字段获取标签信息，不自动生成标签
                let tags = [];
                if (data['关键词'] && Array.isArray(data['关键词']) && data['关键词'].length > 0) {
                    tags = data['关键词'];
                }

                characterCards.push({
                    id: idCounter++,
                    name: name,
                    description: description,
                    tags: tags,
                    rawData: data,  // 保存原始数据，方便详情页使用
                    originalName: name  // 保存原始键名，用于编辑模式下的API请求
                });
            }

            // 从character_cards文件夹加载角色卡
            try {
                const response = await fetch('/api/characters/character-card/list');
                if (response.ok) {
                    const data = await response.json();
                    if (data.success) {
                        for (const card of data.character_cards) {
                            characterCards.push({
                                id: idCounter++,
                                name: card.name,
                                description: card.description,
                                tags: card.tags,
                                rawData: card.rawData
                            });
                        }
                    }
                }
            } catch (error) {
                console.error('从character_cards文件夹加载角色卡失败:', error);
            }

            // 扫描模型文件夹中的character_settings JSON文件（兼容旧格式）
            for (const model of availableModels) {
                try {
                    // 调用API获取模型文件列表
                    const response = await fetch(`/api/live2d/model_files/${model.name}`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success) {
                            // 检查是否有*.chara.json格式的角色卡文件
                            const jsonFiles = data.json_files || [];
                            const characterSettingsFiles = jsonFiles.filter(file => 
                                file.endsWith('.chara.json')
                            );

                            // 如果找到character_settings文件，解析并添加到角色卡列表
                            for (const file of characterSettingsFiles) {
                                try {
                                    // 获取完整的文件内容
                                    // 构建正确的文件URL - 从模型配置文件路径推断
                                    const modelJsonUrl = model.path;
                                    const modelRootUrl = modelJsonUrl.substring(0, modelJsonUrl.lastIndexOf('/') + 1);
                                    const fileUrl = modelRootUrl + file;
                                    
                                    const fileResponse = await fetch(fileUrl);
                                    if (fileResponse.ok) {
                                        const jsonData = await fileResponse.json();
                                        // 检查是否包含"type": "character_settings"
                                        if (jsonData && jsonData.type === 'character_settings') {
                                            characterCards.push({
                                                id: idCounter++,
                                                name: jsonData.name || `${model.name}_settings`,
                                                description: jsonData.description || '角色设置文件',
                                                tags: jsonData.tags || [],
                                                rawData: jsonData  // 保存原始数据，方便详情页使用
                                            });
                                        }
                                    }
                                } catch (fileError) {
                                    console.error(`解析文件${file}失败:`, fileError);
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error(`获取模型${model.name}文件列表失败:`, error);
                }
            }

            // 渲染角色卡列表
            if (characterCardsList) {
                // 清空列表
                characterCardsList.innerHTML = '';
                
                if (characterCards.length > 0) {
                    // 创建角色卡卡片
                    characterCards.forEach(card => {
                        const cardElement = document.createElement('div');
                        cardElement.className = 'card fluent-card';
                        cardElement.innerHTML = `
                            <div class="card-header">
                                <h3 class="card-title" style="font-size: 18px; font-weight: bold;">${card.name}</h3>
                            </div>
                            <div class="card-content">
                                <p class="card-description">${card.description}</p>
                                <div class="tags-container">
                                    ${card.tags.map(tag => `<span class="tag">${tag}<span class="tag-remove" onclick="removeTag(this, 'character-card')">×</span></span>`).join('')}
                                </div>
                            </div>
                        `;
                        // 添加点击事件展开角色卡区域
                        cardElement.addEventListener('click', () => expandCharacterCardSection(card));
                        characterCardsList.appendChild(cardElement);
                    });
                } else {
                    // 显示空状态
                    characterCardsList.innerHTML = `
                        <div class="empty-state">
                            <p data-i18n="steam.noCharacterCards">暂无角色卡</p>
                            <button class="btn btn-secondary" onclick="loadCharacterCards()" data-i18n="steam.refresh">刷新列表</button>
                        </div>
                    `;
                }
            }
            
            // 将角色卡列表保存到全局变量
            globalCharacterCards = characterCards;
    }
    
    // 展开角色卡区域并填充数据
    function expandCharacterCardSection(card) {
        // 更新当前打开的角色卡ID
        currentCharacterCardId = card.id;
        
        // 设置当前编辑的角色卡ID（启用编辑模式）
        currentEditCardId = card.id;
        
        // 保存当前编辑的角色卡原始键名
        currentEditCardOriginalName = card.originalName;
        
        // 获取原始数据，确保存在 - 兼容数据直接在card对象中的情况
        const rawData = card.rawData || card || {};
        
        // 提取所需信息，同时兼容中英文字段名称
            const nickname = rawData['昵称'] || rawData['档案名'] || rawData['name'] || card.name || '暂无昵称';
            const gender = rawData['性别'] || rawData['gender'] || '未知';
            const age = rawData['年龄'] || rawData['age'] || '未知';
            const description = rawData['描述'] || rawData['description'] || card.description || '暂无描述';
            const systemPrompt = rawData['设定'] || rawData['system_prompt'] || rawData['prompt_setting'] || '';
        
        // 处理模型默认值
        let live2d = rawData['live2d'] || (rawData['model'] && rawData['model']['name']);
        const modelSelect = document.getElementById('model-select');
        
        // 确保live2d值存在于模型选择器中
        if (!live2d || !Array.from(modelSelect.options).some(option => option.value === live2d)) {
            // 使用第一个可用的模型作为默认值
            if (availableModels.length > 0) {
                live2d = availableModels[0].name;
                console.log('使用第一个可用模型作为默认值:', live2d);
            } else {
                live2d = '';
            }
        }
        
        // 处理音色默认值
        let voiceId = rawData['voice_id'] || (rawData['voice'] && rawData['voice']['voice_id']);
        const voiceSelect = document.getElementById('voice-select');
        
        // 确保voiceId值存在于音色选择器中
        if (!voiceId || !Array.from(voiceSelect.options).some(option => option.value === voiceId)) {
            // 使用第一个可用的音色作为默认值
            if (window.availableVoices && Object.keys(window.availableVoices).length > 0) {
                voiceId = Object.keys(window.availableVoices)[0];
                console.log('使用第一个可用音色作为默认值:', voiceId);
            } else {
                voiceId = '';
            }
        }
        
        // 填充角色卡区域数据
        document.getElementById('character-card-name').value = nickname;
        // 编辑模式下锁定名称输入框
        document.getElementById('character-card-name').readOnly = true;
        // 显示编辑模式标识
        document.getElementById('edit-mode-lock').style.display = 'block';
        document.getElementById('character-card-gender').value = gender;
        document.getElementById('character-card-age').value = age;
        document.getElementById('character-card-description').value = description;
        document.getElementById('character-card-setting').value = systemPrompt;
        
        // 更新模型选择
        modelSelect.value = live2d;
        
        // 更新音色选择
        voiceSelect.value = voiceId || '';
        
        // 更新标签
        const tagsContainer = document.getElementById('character-card-tags-container');
        tagsContainer.innerHTML = '';
        if (card.tags && card.tags.length > 0) {
            card.tags.forEach(tag => {
                const tagElement = document.createElement('span');
                tagElement.className = 'tag';
                tagElement.innerHTML = `${tag}<span class="tag-remove" onclick="removeTag(this, 'character-card')">×</span>`;
                tagsContainer.appendChild(tagElement);
            });
        }
        
        // 更新注意事项
        let notes = '';
        if (rawData['注意事项']) {
            notes = rawData['注意事项'];
        } else if (rawData['notes']) {
            notes = rawData['notes'];
        }
        
        if (notes) {
            const notesInput = document.getElementById('notes-input');
            const notesCounter = document.getElementById('notes-counter');
            if (notesInput && notesCounter) {
                notesInput.value = notes;
                notesCounter.textContent = `${notes.length}/30`;
            }
        } else {
            // 清空注意事项
            const notesInput = document.getElementById('notes-input');
            const notesCounter = document.getElementById('notes-counter');
            if (notesInput && notesCounter) {
                notesInput.value = '';
                notesCounter.textContent = '0/30';
            }
        }
        
        // 显示角色卡区域
        const characterCardLayout = document.getElementById('character-card-layout');
        characterCardLayout.style.display = 'flex';
        
        // 滚动到角色卡区域
        characterCardLayout.scrollIntoView({ behavior: 'smooth', block: 'start' });
        
        // 刷新Live2D预览
        if (live2d && live2d !== '') {
            // 从availableModels中查找对应的modelInfo
            const modelInfo = availableModels.find(model => model.name === live2d);
            // 调用loadLive2DModelByName函数刷新预览，传递modelInfo以避免重复API调用
            loadLive2DModelByName(live2d, modelInfo);
        }
        
        // 更新角色卡预览
        updateCardPreview();
        
        // 更新标签预览
        updateTagsPreview();
        
        // 更新注意事项预览
        updateNotesPreview();
    }
    
    // 保存角色卡
    function saveCharacterCard() {
            console.log('saveCharacterCard函数被调用');
            // 收集角色卡参数
            const name = document.getElementById('character-card-name').value;
            const gender = document.getElementById('character-card-gender').value;
            const age = document.getElementById('character-card-age').value;
            const description = document.getElementById('character-card-description').value;
            const setting = document.getElementById('character-card-setting').value;
            let selectedModelName = document.getElementById('model-select').value;
            const selectedVoicePrefix = document.getElementById('voice-select').value;
            console.log('表单数据:', {name, gender, age, description, setting, selectedModelName, selectedVoicePrefix});
            
            if (!name) {
                showMessage('请输入角色卡名称', 'error');
                return;
            }
            
            // 设置默认模型
            if (!selectedModelName) {
                // 使用第一个可用的模型作为默认值
                if (availableModels.length > 0) {
                    selectedModelName = availableModels[0].name;
                    console.log('使用第一个可用模型作为默认值:', selectedModelName);
                } else {
                    selectedModelName = '';
                    console.log('没有可用的模型');
                }
            }
            
            // 获取选中的音色信息
            let voiceId = null;
            if (selectedVoicePrefix && window.availableVoices) {
                // 查找对应的音色信息
                Object.entries(window.availableVoices).forEach(([id, voiceData]) => {
                    if (voiceData.prefix === selectedVoicePrefix || id === selectedVoicePrefix) {
                        voiceId = id;
                    }
                });
            }
            
            // 如果没有找到voiceId，使用默认值
            if (!voiceId && window.availableVoices) {
                // 获取第一个可用的voiceId作为默认值
                voiceId = Object.keys(window.availableVoices)[0] || null;
                console.log('使用默认voiceId:', voiceId);
            }
            
            // 获取当前语言
            const currentLanguage = typeof i18next !== 'undefined' ? i18next.language : 'zh-CN';
            
            // 构建猫娘数据对象 - 根据当前语言动态设置字段名称
            const catgirlData = {};
            
            // 根据语言设置所有字段名称
            if (currentLanguage === 'zh-CN') {
                // 中文字段名
                catgirlData['档案名'] = name;
                catgirlData['性别'] = gender;
                catgirlData['年龄'] = age;
                catgirlData['描述'] = description;
            } else {
                // 英文字段名
                catgirlData['name'] = name;
                catgirlData['gender'] = gender;
                catgirlData['age'] = age;
                catgirlData['description'] = description;
            }
            
            // 技术相关字段保持统一英文名称
            catgirlData.live2d = selectedModelName;
            catgirlData.system_prompt = setting;
            

            
            // 获取角色卡标签
            const characterCardTags = [];
            const tagElements = document.querySelectorAll('#character-card-tags-container .tag');
            if (tagElements && tagElements.length > 0) {
                tagElements.forEach(tagElement => {
                    const tagText = tagElement.textContent.replace('×', '').trim();
                    if (tagText) {
                        characterCardTags.push(tagText);
                    }
                });
            }
            
            // 根据语言设置标签字段名称
            if (currentLanguage === 'zh-CN') {
                catgirlData['关键词'] = characterCardTags;
            } else {
                catgirlData['tags'] = characterCardTags;
            }
            
            // 获取注意事项
            const notesInput = document.getElementById('notes-input');
            const notes = notesInput ? notesInput.value.trim() : '';
            
            // 根据语言设置注意事项字段名称
            if (currentLanguage === 'zh-CN') {
                if (notes) {
                    catgirlData['注意事项'] = notes;
                }
            } else {
                if (notes) {
                    catgirlData['notes'] = notes;
                }
            }
            
            // 显示保存状态
            showMessage('正在保存角色...', 'info');
            
            // 调用API保存角色：如果是编辑模式则使用PUT更新，否则使用POST创建
            const isEditMode = currentEditCardId !== null;
            // 编辑模式下使用原始键名构建API URL，确保正确匹配后端存储
            const apiUrl = isEditMode ? `/api/characters/catgirl/${encodeURIComponent(currentEditCardOriginalName)}` : '/api/characters/catgirl';
            const method = isEditMode ? 'PUT' : 'POST';
            
            fetch(apiUrl, {
                method: method,
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(catgirlData)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP错误，状态码: ${response.status}`);
                }
                return response.json();
            })
            .then(result => {
                if (result.success) {
                    console.log('角色保存成功:', result);
                    showMessage('角色已保存', 'success');
                    
                    // 将需要同步的数据存储到localStorage中，以便在切换到创意工坊上传页面时使用
                    try {
                        // 1. 获取角色卡标签
                        const characterCardTags = [];
                        const tagElements = document.querySelectorAll('#character-card-tags-container .tag');
                        tagElements.forEach(tagElement => {
                            const tagText = tagElement.textContent.replace('×', '').trim();
                            if (tagText) {
                                characterCardTags.push(tagText);
                            }
                        });
                        
                        // 2. 获取角色卡描述和注意事项
                        const characterDescriptionElement = document.getElementById('character-card-description');
                        const cardDescription = characterDescriptionElement ? characterDescriptionElement.value : '';
                        
                        const notesInput = document.getElementById('notes-input');
                        const cardNotes = notesInput ? notesInput.value.trim() : '';
                        
                        // 3. 将数据存储到localStorage
                        const workshopSyncData = {
                            tags: characterCardTags,
                            description: cardDescription,
                            notes: cardNotes
                        };
                        localStorage.setItem('workshopSyncData', JSON.stringify(workshopSyncData));
                        console.log('已将同步数据存储到localStorage:', workshopSyncData);
                        
                        // 显示同步成功的提示
                        showMessage('角色卡数据已同步到创意工坊上传页面', 'success');
                    } catch (error) {
                        console.error('存储同步数据时出错:', error);
                        showMessage('同步数据存储失败', 'error');
                    }
                    
                    // 重置当前编辑ID
                    currentEditCardId = null;
                    
                    // 保存后刷新列表
                    loadCharacterCards();
                    
                    // 设置刷新后要显示的标签页
                    localStorage.setItem('lastActiveTab', 'character-cards-content');
                } else {
                    throw new Error(result.error || '保存失败');
                }
            })
            .catch(error => {
                console.error('保存角色失败:', error);
                showMessage(`保存角色失败: ${error.message}`, 'error');
            });
        }
        
        // 加载角色卡
        function loadCharacterCard() {
            // 这里将实现加载角色卡的逻辑
            console.log('加载角色卡');
            showMessage('角色卡已加载', 'info');
        }
        
        // 删除角色卡
        function handleUploadToWorkshop() {
            console.log('handleUploadToWorkshop函数被调用');
            // 收集角色卡参数
            const name = document.getElementById('character-card-name').value;
            const gender = document.getElementById('character-card-gender').value;
            const age = document.getElementById('character-card-age').value;
            const description = document.getElementById('character-card-description').value;
            const setting = document.getElementById('character-card-setting').value;
            let selectedModelName = document.getElementById('model-select').value;
            const selectedVoicePrefix = document.getElementById('voice-select').value;
            
            if (!name) {
                showMessage('请输入角色卡名称', 'error');
                return;
            }
            
            // 设置默认模型
            if (!selectedModelName) {
                if (availableModels.length > 0) {
                    selectedModelName = availableModels[0].name;
                } else {
                    showMessage('没有可用的模型', 'error');
                    return;
                }
            }
            
            // 获取选中的音色信息
            let voiceId = null;
            if (selectedVoicePrefix && window.availableVoices) {
                Object.entries(window.availableVoices).forEach(([id, voiceData]) => {
                    if (voiceData.prefix === selectedVoicePrefix || id === selectedVoicePrefix) {
                        voiceId = id;
                    }
                });
            }
            
            if (!voiceId && window.availableVoices) {
                voiceId = Object.keys(window.availableVoices)[0] || null;
            }
            
            // 获取当前语言
            const currentLanguage = typeof i18next !== 'undefined' ? i18next.language : 'zh-CN';
            
            // 构建猫娘数据对象
            const catgirlData = {};
            
            if (currentLanguage === 'zh-CN') {
                catgirlData['档案名'] = name;
                catgirlData['性别'] = gender;
                catgirlData['年龄'] = age;
                catgirlData['描述'] = description;
            } else {
                catgirlData['name'] = name;
                catgirlData['gender'] = gender;
                catgirlData['age'] = age;
                catgirlData['description'] = description;
            }
            
            catgirlData.live2d = selectedModelName;
            catgirlData.system_prompt = setting;
            

            
            // 获取角色卡标签
            const characterCardTags = [];
            const tagElements = document.querySelectorAll('#character-card-tags-container .tag');
            if (tagElements && tagElements.length > 0) {
                tagElements.forEach(tagElement => {
                    const tagText = tagElement.textContent.replace('×', '').trim();
                    if (tagText) {
                        characterCardTags.push(tagText);
                    }
                });
            }
            
            if (currentLanguage === 'zh-CN') {
                catgirlData['关键词'] = characterCardTags;
            } else {
                catgirlData['tags'] = characterCardTags;
            }
            
            // 获取注意事项
            const notesInput = document.getElementById('notes-input');
            const notes = notesInput ? notesInput.value.trim() : '';
            
            if (currentLanguage === 'zh-CN') {
                if (notes) {
                    catgirlData['注意事项'] = notes;
                }
            } else {
                if (notes) {
                    catgirlData['notes'] = notes;
                }
            }
            
            // 获取当前选中模型的文件夹路径
            const selectedModelInfo = availableModels.find(model => model.name === selectedModelName);
            if (!selectedModelInfo) {
                showMessage('未找到选中的模型信息', 'error');
                return;
            }
            
            // 从模型路径中提取文件夹路径（假设模型路径格式为：models/xxx/xxx.model3.json）
            const modelPath = selectedModelInfo.path;
            const modelFolderPath = modelPath.substring(0, modelPath.lastIndexOf('/'));
            
            // 构建保存角色卡的文件名和路径
            const charaFileName = `${name}.chara.json`;
            const charaFilePath = `${modelFolderPath}/${charaFileName}`;
            
            // 显示保存状态
            showMessage('正在保存角色卡到模型文件夹...', 'info');
            
            // 调用API保存角色卡到模型文件夹
            console.log('开始调用API保存角色卡');
            fetch('/api/characters/catgirl/save-to-model-folder', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    charaData: catgirlData,
                    modelName: selectedModelName,
                    fileName: charaFileName
                })
            })
            .then(response => {
                console.log('API响应:', response);
                if (!response.ok) {
                    throw new Error(`HTTP错误，状态码: ${response.status}`);
                }
                return response.json();
            })
            .then(result => {
                console.log('API响应数据:', result);
                if (result.success) {
                    console.log('角色卡保存到模型文件夹成功:', result);
                    showMessage('角色卡已保存到模型文件夹', 'success');
                    
                    // 填充上传表单，使用后端返回的实际文件系统路径
                    console.log('开始填充上传表单');
                    const itemTitle = document.getElementById('item-title');
                    const itemDescription = document.getElementById('item-description');
                    const contentFolder = document.getElementById('content-folder');
                    const tagsContainer = document.getElementById('tags-container');
                    
                    console.log('找到的表单元素:', { itemTitle, itemDescription, contentFolder, tagsContainer });
                    
                    if (itemTitle) itemTitle.value = name;
                    if (itemDescription) {
                        // 构建包含注意事项的描述
                        let fullDescription = description;
                        if (notes && notes.trim()) {
                            if (fullDescription.trim()) {
                                fullDescription += '\n\n';
                            }
                            // 根据当前语言选择注意事项标题
                            const currentLanguage = typeof i18next !== 'undefined' ? i18next.language : 'zh-CN';
                            const notesTitle = currentLanguage === 'zh-CN' ? '注意事项：\n' : 'Notes:\n';
                            fullDescription += notesTitle + notes.trim();
                        }
                        itemDescription.value = fullDescription;
                        console.log('设置的完整描述内容:', fullDescription);
                    }
                    if (contentFolder) contentFolder.value = result.modelFolderPath;
                    
                    // 添加角色卡标签到上传标签
                    if (tagsContainer) {
                        tagsContainer.innerHTML = '';
                        characterCardTags.forEach(tag => {
                            addTag(tag);
                        });
                    }
                    
                } else {
                    console.log('API返回失败:', result.error);
                    showMessage(`保存角色卡到模型文件夹失败: ${result.error || '未知错误'}`, 'error');
                }
            })
            .catch(error => {
                console.error('保存角色卡到模型文件夹失败:', error);
                showMessage(`保存角色卡到模型文件夹失败: ${error.message}`, 'error');
            })
            .finally(() => {
                // 无论API调用是否成功，都切换到上传区域
                console.log('调用toggleUploadSection函数');
                // 先确保本地物品标签页可见
                switchTab('local-items-content');
                // 然后显示上传表单区域
                toggleUploadSection();
            });
        }

        function deleteCharacterCard(cardId) {
            // 使用自定义确认模态框替换默认的confirm
            showConfirmModal('确定要删除这个角色卡吗？', () => {
                console.log('正在删除角色卡，ID:', cardId);
                
                // 根据cardId找到对应的角色卡数据
                const card = globalCharacterCards.find(c => c.id === cardId);
                if (!card) {
                    showMessage('未找到角色卡数据', 'error');
                    return;
                }
                
                // 检查是否有原始键名
                if (!card.originalName) {
                    showMessage('角色卡数据不完整，无法删除', 'error');
                    return;
                }
                
                showMessage('正在删除角色卡...', 'info');
                
                // 构建删除API的URL
                const deleteUrl = `/api/characters/catgirl/${encodeURIComponent(card.originalName)}`;
                
                // 调用API删除角色卡
                fetch(deleteUrl, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                })
                .then(response => {
                    if (!response.ok) {
                        // 处理400和404错误
                        return response.json().then(data => {
                            throw new Error(data.error || `HTTP错误，状态码: ${response.status}`);
                        });
                    }
                    return response.json();
                })
                .then(async result => {
                    console.log('角色卡删除成功:', result);
                    showMessage('角色卡已删除', 'success');
                    
                    // 删除后刷新列表（等待刷新完成）
                    await loadCharacterCards();
                    
                    // 重置当前编辑状态，跳过确认对话框
                    clearCharacterCardForm(true);
                    
                    // 刷新页面
                    setTimeout(() => {
                        window.location.reload();
                    }, 1000);
                })
                .catch(error => {
                    console.error('删除角色卡失败:', error);
                    showMessage(`删除角色卡失败: ${error.message}`, 'error');
                });
            });
        }
        
        // 从模态框中删除角色卡
        function deleteCharacterCardModal() {
            if (currentCharacterCardId) {
                deleteCharacterCard(currentCharacterCardId);
            } else {
                showMessage('未选择要删除的角色卡', 'error');
            }
        }
        
        // 从模态框中编辑角色卡
        function editCharacterCardModal() {
            if (currentCharacterCardId) {
                // 展开角色卡编辑区域
                toggleCharacterCardSection();
                
                // 调用编辑角色卡函数
                editCharacterCard(currentCharacterCardId);
            } else {
                showMessage('未选择要编辑的角色卡', 'error');
            }
        }



        // 编辑角色卡
        
        // 编辑角色卡函数
        function editCharacterCard(cardId) {
            // 根据cardId找到对应的角色卡数据
            const card = globalCharacterCards.find(c => c.id === cardId);
            if (!card) {
                showMessage('未找到角色卡数据', 'error');
                return;
            }
            
            // 设置当前编辑的角色卡ID
            currentEditCardId = cardId;
            
            // 显示角色卡创建区域
            const characterCardLayout = document.getElementById('character-card-layout');
            characterCardLayout.style.display = 'flex';
            
            // 将角色卡数据填充到表单字段中
            document.getElementById('character-card-name').value = card.name || '';
            // 编辑模式下锁定名称输入框
            document.getElementById('character-card-name').readOnly = true;
            document.getElementById('character-card-gender').value = card.rawData.性别 || '';
            document.getElementById('character-card-age').value = card.rawData.年龄 || '';
            document.getElementById('character-card-description').value = card.description || '';
            document.getElementById('character-card-setting').value = card.rawData.system_prompt || card.rawData.prompt_setting || card.rawData['设定'] || '';
            
            // 加载模型和音色
            // 先检查card.rawData.model是否存在（新格式）
            let modelName = '';
            if (card.rawData.model && card.rawData.model.name) {
                modelName = card.rawData.model.name;
            } else if (card.rawData.model_path) {
                // 旧格式兼容：从model_path中提取模型名称
                // 假设model_path的格式是类似于"models/xxx/xxx.model3.json"的路径
                // 我们需要从中提取模型名称
                const pathParts = card.rawData.model_path.split('/');
                if (pathParts.length > 1) {
                    // 取倒数第二个部分作为模型名称（假设路径格式为models/模型名称/模型文件.model3.json）
                    modelName = pathParts[pathParts.length - 2];
                }
            } else if (card.rawData.live2d) {
                // 新格式：直接使用live2d字段
                modelName = card.rawData.live2d;
            }
            
            // 根据模型名称选择对应的模型
            const modelSelect = document.getElementById('model-select');
            
            // 确保modelName存在于模型选择器中
            let foundOption = false;
            if (modelName) {
                // 尝试直接通过value匹配
                const option = modelSelect.querySelector(`option[value="${modelName}"]`);
                if (option) {
                    modelSelect.value = modelName;
                    foundOption = true;
                } else {
                    // 如果直接匹配失败，尝试通过文本内容匹配
                    for (let i = 0; i < modelSelect.options.length; i++) {
                        if (modelSelect.options[i].textContent === modelName) {
                            modelSelect.selectedIndex = i;
                            foundOption = true;
                            break;
                        }
                    }
                }
            }
            
            // 如果没有找到匹配的模型，使用第一个可用的模型作为默认值
            if (!foundOption) {
                if (modelSelect.options.length > 1) { // 跳过默认的"选择模型"选项
                    modelSelect.selectedIndex = 1;
                    modelName = modelSelect.value;
                    console.log('使用第一个可用模型作为默认值:', modelName);
                } else {
                    console.log('没有可用的模型选项');
                }
            }
            
            // 手动触发change事件以加载Live2D模型
            // 这是必要的，因为程序化设置value不会触发change事件
            if (modelSelect.value) {
                modelSelect.dispatchEvent(new Event('change'));
            }
            
            // 加载音色
            let voiceValue = '';
            // 检查是否有voice对象（新格式）
            if (card.rawData.voice) {
                voiceValue = card.rawData.voice.prefix || card.rawData.voice.voice_id;
            } else if (card.rawData.voice_id) {
                // 旧格式：使用voice_id
                voiceValue = card.rawData.voice_id;
            }
            
            // 根据音色值选择对应的音色
            const voiceSelect = document.getElementById('voice-select');
            
            // 确保voiceValue存在于音色选择器中
            let foundVoiceOption = false;
            if (voiceValue) {
                // 尝试直接通过value匹配
                const option = voiceSelect.querySelector(`option[value="${voiceValue}"]`);
                if (option) {
                    voiceSelect.value = voiceValue;
                    foundVoiceOption = true;
                } else {
                    // 如果直接匹配失败，尝试通过文本内容匹配
                    for (let i = 0; i < voiceSelect.options.length; i++) {
                        if (voiceSelect.options[i].textContent === voiceValue) {
                            voiceSelect.selectedIndex = i;
                            foundVoiceOption = true;
                            break;
                        }
                    }
                }
            }
            
            // 如果没有找到匹配的音色，使用第一个可用的音色作为默认值
            if (!foundVoiceOption) {
                if (voiceSelect.options.length > 1) { // 跳过默认的"选择音色"选项
                    voiceSelect.selectedIndex = 1;
                    voiceValue = voiceSelect.value;
                    console.log('使用第一个可用音色作为默认值:', voiceValue);
                } else {
                    console.log('没有可用的音色选项');
                }
            }
            
            // 加载标签
            clearTags('character-card');
            if (card.tags && card.tags.length > 0) {
                card.tags.forEach(tag => {
                    addTag(tag, 'character-card');
                });
            }
            
            // 检查是否选择了音色，如果是则添加Voice标签
            const currentVoiceValue = voiceSelect.value;
            if (currentVoiceValue) {
                // 检查是否已经有Voice标签
                const tagsContainer = document.getElementById('character-card-tags-container');
                const existingTags = Array.from(tagsContainer.querySelectorAll('.tag'));
                let hasVoiceTag = false;
                
                existingTags.forEach(tag => {
                    const tagText = tag.textContent.replace('×', '').trim();
                    if (tagText === 'Voice' || tagText === '语音') {
                        hasVoiceTag = true;
                    }
                });
                
                // 如果没有Voice标签，添加它
                if (!hasVoiceTag) {
                    addCharacterCardTag('character-card', 'Voice');
                }
            }
            
            // 加载注意事项
            let notes = '';
            if (card.rawData['注意事项']) {
                notes = card.rawData['注意事项'];
            } else if (card.rawData['notes']) {
                notes = card.rawData['notes'];
            }
            
            if (notes) {
                const notesInput = document.getElementById('notes-input');
                const notesCounter = document.getElementById('notes-counter');
                if (notesInput && notesCounter) {
                    notesInput.value = notes;
                    notesCounter.textContent = `${notes.length}/30`;
                }
            }
            
            // 更新预览区域
            updateCardPreview();
            updateTagsPreview();
            updateNotesPreview();
            
            showMessage('角色卡数据已加载到编辑区域', 'success');
        }
        

        
        // 扫描Live2D模型
        function scanModels() {
            showMessage(window.t ? window.t('steam.scanningModels') : '正在扫描模型...', 'info');
            
            const modelSelect = document.getElementById('model-select');
            // 保存当前选中的模型值
            const currentSelectedValue = modelSelect.value;
            
            // 调用API获取模型列表
            fetch('/api/live2d/models')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP错误，状态码: ${response.status}`);
                }
                return response.json();
            })
            .then(models => {
                // 存储模型列表到全局变量
                availableModels = models;
                
                // 清空下拉列表
                modelSelect.innerHTML = '';
                
                // 添加默认选项
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = window.t ? window.t('steam.selectModel') : '选择模型';
                defaultOption.disabled = true;
                // 只有当没有当前选中值时，才默认选中这个选项
                defaultOption.selected = !currentSelectedValue;
                modelSelect.appendChild(defaultOption);
                
                // 标记是否找到了当前选中的模型
                let foundCurrentSelected = false;
                
                // 添加扫描到的模型
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.name;
                    option.textContent = model.name;
                    
                    // 如果当前选项与之前选中的值匹配，则选中它
                    if (model.name === currentSelectedValue) {
                        option.selected = true;
                        foundCurrentSelected = true;
                    }
                    
                    modelSelect.appendChild(option);
                });
                
                // 如果找到了当前选中的模型，并且live2dPreviewManager存在，则确保预览区域显示模型而不是占位符
                    if (foundCurrentSelected && live2dPreviewManager) {
                        document.getElementById('live2d-preview-canvas').style.display = '';
                        document.querySelector('.preview-placeholder').style.display = 'none';
                    }
                    
                    // 显示扫描完成提示，使用与物品扫描相同的成功提示样式
                    const successMessage = window.t ? window.t('steam.scanComplete', {count: models.length}) : `扫描完成，共找到 ${models.length} 个模型`;
                    
                    const messageElement = document.createElement('div');
                    messageElement.innerHTML = successMessage;
                    messageElement.style.cssText = `
                        position: fixed;
                        top: 60px;
                        right: 20px;
                        padding: 15px 20px;
                        background: #e8f5e9;
                        color: #2e7d32;
                        border-radius: 6px;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                        z-index: 99999;
                        font-weight: bold;
                        opacity: 0;
                        transform: translateY(-10px);
                        transition: opacity 0.3s ease, transform 0.3s ease;
                    `;
                    
                    document.body.appendChild(messageElement);
                    
                    // 触发动画
                    setTimeout(() => {
                        messageElement.style.opacity = '1';
                        messageElement.style.transform = 'translateY(0)';
                    }, 10);
                    
                    // 3秒后自动消失
                    setTimeout(() => {
                        messageElement.style.opacity = '0';
                        messageElement.style.transform = 'translateY(-10px)';
                        setTimeout(() => {
                            messageElement.remove();
                        }, 300);
                    }, 3000);
            })
            .catch(error => {
                console.error('扫描模型失败:', error);
                showMessage(window.t ? window.t('steam.modelScanError') : '扫描模型失败', 'error');
            });
        }
        
        // 处理模型上传
        function handleModelUpload(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;

            showMessage(window.t ? window.t('steam.uploadingModel') : '正在导入模型...', 'info');

            try {
                const formData = new FormData();
                
                for (const file of files) {
                    // 保留文件的相对路径
                    formData.append('files', file, file.webkitRelativePath || file.name);
                }

                fetch('/api/live2d/upload_model', {
                    method: 'POST',
                    body: formData
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP错误，状态码: ${response.status}`);
                    }
                    return response.json();
                })
                .then(result => {
                    if (result.success) {
                        showMessage(window.t ? window.t('steam.uploadSuccess') : '模型导入成功！', 'success');
                        // 重新扫描模型列表
                        scanModels();
                    } else {
                        showMessage(window.t ? window.t('steam.uploadError', {error: result.error}) : `导入出错: ${result.error}`, 'error');
                    }
                })
                .catch(error => {
                    console.error('导入模型失败:', error);
                    showMessage(window.t ? window.t('steam.uploadError', {error: error.message}) : `导入出错: ${error.message}`, 'error');
                })
                .finally(() => {
                    // 清空文件选择
                    event.target.value = '';
                });
            } catch (error) {
                console.error('导入模型失败:', error);
                showMessage(window.t ? window.t('steam.uploadError', {error: error.message}) : `导入出错: ${error.message}`, 'error');
                // 清空文件选择
                event.target.value = '';
            }
        }
        
        // 全局变量：当前选择的模型信息
        let selectedModelInfo = null;
        
        // 初始化模型选择功能
        // 音色相关函数（功能暂未实现）
        // 加载音色列表
        async function loadVoices() {
            // 显示扫描开始提示
            showMessage(window.t ? window.t('steam.scanningVoices') : '正在扫描音色...', 'info');
            
            try {
                const response = await fetch('/api/characters/voices');
                const data = await response.json();
                const select = document.getElementById('voice-select');
                if (select) {
                    // 保存完整的音色数据到全局变量
                    window.availableVoices = data.voices;
                    
                    // 清空现有选项
                    while (select.firstChild) {
                        select.removeChild(select.firstChild);
                    }
                    
                    // 添加默认选项
                    const defaultOption = document.createElement('option');
                    defaultOption.value = '';
                    defaultOption.textContent = window.t ? window.t('steam.selectVoice') : '请选择音色';
                    select.appendChild(defaultOption);
                    
                    // 添加音色选项
                    const voiceCount = Object.keys(data.voices).length;
                    Object.entries(data.voices).forEach(([voiceId, voiceData]) => {
                        const option = document.createElement('option');
                        option.value = voiceData.prefix || voiceId;
                        option.textContent = voiceData.prefix || voiceId;
                        select.appendChild(option);
                    });
                    
                    // 显示扫描完成提示
                    const successMessage = window.t ? window.t('steam.scanComplete', {count: voiceCount}) : `扫描完成，共找到 ${voiceCount} 个音色`;
                    
                    // 使用与物品扫描相同的成功提示样式
                    const messageElement = document.createElement('div');
                    messageElement.innerHTML = successMessage;
                    messageElement.style.cssText = `
                        position: fixed;
                        top: 60px;
                        right: 20px;
                        padding: 15px 20px;
                        background: #e8f5e9;
                        color: #2e7d32;
                        border-radius: 6px;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                        z-index: 99999;
                        font-weight: bold;
                        opacity: 0;
                        transform: translateY(-10px);
                        transition: opacity 0.3s ease, transform 0.3s ease;
                    `;
                    
                    document.body.appendChild(messageElement);
                    
                    // 触发动画
                    setTimeout(() => {
                        messageElement.style.opacity = '1';
                        messageElement.style.transform = 'translateY(0)';
                    }, 10);
                    
                    // 3秒后自动消失
                    setTimeout(() => {
                        messageElement.style.opacity = '0';
                        messageElement.style.transform = 'translateY(-10px)';
                        setTimeout(() => {
                            messageElement.remove();
                        }, 300);
                    }, 3000);
                }
            } catch (error) {
                console.error('加载音色列表失败:', error);
                showMessage(window.t ? window.t('steam.voiceScanError') : '扫描音色失败', 'error');
            }
        }
        
        // 扫描音色功能
        function scanVoices() {
            loadVoices();
        }
        
        // 更新文件选择显示
        function updateFileDisplay() {
            const fileInput = document.getElementById('audioFile');
            const fileNameDisplay = document.getElementById('fileNameDisplay');
            
            // 检查必要的DOM元素是否存在
            if (!fileInput || !fileNameDisplay) {
                return;
            }
            
            if (fileInput.files.length > 0) {
                fileNameDisplay.textContent = fileInput.files[0].name;
            } else {
                fileNameDisplay.textContent = window.t ? window.t('voice.noFileSelected') : '未选择文件';
            }
        }
        
        // 页面加载时获取 lanlan_name
        (async function initLanlanName() {
            try {
                // 优先从 URL 获取 lanlan_name
                const urlParams = new URLSearchParams(window.location.search);
                let lanlanName = urlParams.get('lanlan_name') || "";
                
                // 如果 URL 中没有，从 API 获取
                if (!lanlanName) {
                    const response = await fetch('/api/config/page_config');
                    const data = await response.json();
                    if (data.success) {
                        lanlanName = data.lanlan_name || "";
                    }
                }
                
                // 设置到隐藏字段
                if (!document.getElementById('lanlan_name')) {
                    const hiddenInput = document.createElement('input');
                    hiddenInput.type = 'hidden';
                    hiddenInput.id = 'lanlan_name';
                    hiddenInput.value = lanlanName;
                    document.body.appendChild(hiddenInput);
                } else {
                    document.getElementById('lanlan_name').value = lanlanName;
                }
                console.log('lanlan_name 已设置:', lanlanName);
            } catch (error) {
                console.error('获取 lanlan_name 失败:', error);
                if (!document.getElementById('lanlan_name')) {
                    const hiddenInput = document.createElement('input');
                    hiddenInput.type = 'hidden';
                    hiddenInput.id = 'lanlan_name';
                    hiddenInput.value = '';
                    document.body.appendChild(hiddenInput);
                }
            }
        })();

        function setFormDisabled(disabled) {
            const audioFileInput = document.getElementById('audioFile');
            const prefixInput = document.getElementById('prefix');
            const registerBtn = document.querySelector('button[onclick="registerVoice()"]');
            
            if (audioFileInput) audioFileInput.disabled = disabled;
            if (prefixInput) prefixInput.disabled = disabled;
            if (registerBtn) registerBtn.disabled = disabled;
        }

        function registerVoice() {
            const fileInput = document.getElementById('audioFile');
            const prefix = document.getElementById('prefix').value.trim();
            const resultDiv = document.getElementById('voice-register-result');
            
            resultDiv.innerHTML = '';
            resultDiv.className = 'result';
            
            if (!fileInput.files.length) {
                resultDiv.innerHTML = window.t ? window.t('voice.pleaseUploadFile') : '请选择音频文件';
                resultDiv.className = 'result error';
                resultDiv.style.color = 'red';
                return;
            }
            
            if (!prefix) {
                resultDiv.innerHTML = window.t ? window.t('voice.pleaseEnterPrefix') : '请填写自定义前缀';
                resultDiv.className = 'result error';
                resultDiv.style.color = 'red';
                return;
            }
            
            // 验证前缀格式
            const prefixRegex = /^[a-zA-Z0-9]{1,10}$/;
            if (!prefixRegex.test(prefix)) {
                resultDiv.innerHTML = window.t ? window.t('voice.prefixFormatError') : '前缀格式错误：不超过10个字符，只支持数字和英文字母';
                resultDiv.className = 'result error';
                resultDiv.style.color = 'red';
                return;
            }
            
            setFormDisabled(true);
            resultDiv.innerHTML = window.t ? window.t('voice.registering') : '正在注册声音，请稍后！';
            resultDiv.style.color = 'green';
            
            const formData = new FormData();
            formData.append('file', fileInput.files[0]);
            formData.append('prefix', prefix);
            
            fetch('/api/characters/voice_clone', {
                method: 'POST',
                body: formData
            })
            .then(res => res.json())
            .then(data => {
                if (data.voice_id) {
                    resultDiv.innerHTML = window.t ? window.t('voice.registerSuccess', {voiceId: data.voice_id}) : '注册成功！voice_id: ' + data.voice_id;
                    resultDiv.style.color = 'green';
                    
                    // 自动更新voice_id到后端
                    const lanlanName = document.getElementById('lanlan_name').value;
                    if (lanlanName) {
                        fetch(`/api/characters/catgirl/voice_id/${encodeURIComponent(lanlanName)}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ voice_id: data.voice_id })
                        }).then(resp => resp.json()).then(res => {
                            if (!res.success) {
                                const errorMsg = res.error || (window.t ? window.t('common.unknownError') : '未知错误');
                                resultDiv.innerHTML += '<br><span class="error" style="color: red;">' + (window.t ? window.t('voice.voiceIdSaveFailed', {error: errorMsg}) : 'voice_id自动保存失败: ' + errorMsg) + '</span>';
                            } else {
                                resultDiv.innerHTML += '<br>' + (window.t ? window.t('voice.voiceIdSaved') : 'voice_id已自动保存到角色');
                                // 如果session被结束，页面会自动刷新
                                if (res.session_restarted) {
                                    resultDiv.innerHTML += '<br><span style="color: blue;">' + (window.t ? window.t('voice.pageWillRefresh') : '当前页面即将自动刷新以应用新语音') + '</span>';
                                    setTimeout(() => {
                                        location.reload();
                                    }, 2000);
                                } else {
                                    resultDiv.innerHTML += '<br><span style="color: blue;">' + (window.t ? window.t('voice.voiceWillTakeEffect') : '新语音将在下次对话时生效') + '</span>';
                                }
                            }
                        }).catch(e => {
                            resultDiv.innerHTML += '<br><span class="error" style="color: red;">' + (window.t ? window.t('voice.voiceIdSaveRequestError') : 'voice_id自动保存请求出错') + '</span>';
                        });
                    }
                    
                    // 重新扫描音色以更新列表
                    setTimeout(() => {
                        loadVoices();
                    }, 1000);
                } else {
                    const errorMsg = data.error || (window.t ? window.t('common.unknownError') : '未知错误');
                    resultDiv.innerHTML = window.t ? window.t('voice.registerFailed', {error: errorMsg}) : '注册失败：' + errorMsg;
                    resultDiv.className = 'result error';
                    resultDiv.style.color = 'red';
                }
                setFormDisabled(false);
            })
            .catch(err => {
                const errorMsg = err?.message || err?.toString() || (window.t ? window.t('common.unknownError') : '未知错误');
                resultDiv.textContent = window.t ? window.t('voice.requestError', {error: errorMsg}) : '请求出错：' + errorMsg;
                resultDiv.className = 'result error';
                resultDiv.style.color = 'red';
                setFormDisabled(false);
            });
        }
        
        // 页面加载时初始化文件选择显示
        window.addEventListener('load', () => {
            // 监听文件选择变化
            const audioFileInput = document.getElementById('audioFile');
            if (audioFileInput) {
                audioFileInput.addEventListener('change', updateFileDisplay);
            }
            
            // 如果 i18next 已经初始化完成，立即更新
            if (window.i18n && window.i18n.isInitialized) {
                updateFileDisplay();
            } else {
                // 延迟更新，等待 i18next 初始化
                setTimeout(updateFileDisplay, 500);
            }
        });
        
        function initModelSelection() {
            const modelSelect = document.getElementById('model-select');
            const openDirBtn = document.querySelector('button[onclick="openModelDirectory()"]');
            
            // 添加模型选择事件监听
            modelSelect.addEventListener('change', () => {
                const selectedModelName = modelSelect.value;
                if (selectedModelName) {
                    // 从全局模型列表中查找对应的modelInfo
                    selectedModelInfo = availableModels.find(model => model.name === selectedModelName);
                    
                    // 加载模型到Live2D预览区域
                    loadLive2DModelByName(selectedModelName, selectedModelInfo);
                    
                    // 启用打开目录按钮
                    openDirBtn.disabled = false;
                } else {
                    selectedModelInfo = null;
                    // 禁用打开目录按钮
                    openDirBtn.disabled = true;
                }
            });
        }
        
        // 通过模型名称加载Live2D模型
        async function loadLive2DModelByName(modelName, modelInfo = null) {
            try {
                // 确保live2dPreviewManager已初始化
                if (!live2dPreviewManager) {
                    await initLive2DPreview();
                }
                
                // 强制resize PIXI应用，确保canvas尺寸正确
                // 这是必要的，因为当容器最初是隐藏的(display:none)时，PIXI的尺寸会是0
                if (live2dPreviewManager && live2dPreviewManager.pixi_app) {
                    const container = document.getElementById('live2d-preview-content');
                    if (container && container.clientWidth > 0 && container.clientHeight > 0) {
                        live2dPreviewManager.pixi_app.renderer.resize(container.clientWidth, container.clientHeight);
                        console.log('PIXI canvas resized to:', container.clientWidth, 'x', container.clientHeight);
                    }
                }
                
                // 如果已经有模型加载，先移除它
                if (live2dPreviewManager && live2dPreviewManager.currentModel) {
                    await live2dPreviewManager.removeModel(true);
                    // 重置当前预览模型引用
                    currentPreviewModel = null;
                }
                
                // 如果没有传入modelInfo，则从API获取模型列表
                if (!modelInfo) {
                    // 调用API获取模型列表，找到对应模型的信息
                    const response = await fetch('/api/live2d/models');
                    if (!response.ok) {
                        throw new Error(`HTTP错误，状态码: ${response.status}`);
                    }
                    
                    const models = await response.json();
                    modelInfo = models.find(model => model.name === modelName);
                    
                    if (!modelInfo) {
                        throw new Error(window.t('steam.modelNotFound', '模型未找到'));
                    }
                }
                
                // 确保获取正确的steam_id，优先使用modelInfo中的item_id
                let finalSteamId = modelInfo.item_id;
                console.log('modelInfo:', modelInfo);
                console.log('finalSteamId:', finalSteamId);
                showMessage((window.t && window.t('live2d.loadingModel', { model: modelName })) || `正在加载模型: ${modelName}...`, 'info');
                
                // 1. Fetch files list
                let filesRes;
                // 根据modelInfo的source字段和finalSteamId决定使用哪个API端点
                if (modelInfo.source === 'user_mods') {
                    // 对于用户mod模型，使用modelName构建URL
                    console.log('Fetching model files for user mod:', modelName);
                    filesRes = await fetch(`/api/live2d/model_files/${encodeURIComponent(modelName)}`);
                } else if (finalSteamId && finalSteamId !== 'undefined') {
                    // 如果提供了finalSteamId，调用专门的API端点
                    filesRes = await fetch(`/api/live2d/model_files_by_id/${finalSteamId}`);
                } else {
                    // 否则使用原来的API端点
                    filesRes = await fetch(`/api/live2d/model_files/${encodeURIComponent(modelName)}`);
                }
                const filesData = await filesRes.json();
                if (!filesData.success) throw new Error(window.t('live2d.modelFilesFetchFailed', '无法获取模型文件列表'));
                
                // 2. Fetch model config
                let modelJsonUrl;
                // 优先使用后端返回的model_config_url（如果有）
                if (filesData.model_config_url) {
                    modelJsonUrl = filesData.model_config_url;
                    console.log('使用后端返回的模型配置URL:', modelJsonUrl);
                } else if (modelInfo.source === 'user_mods') {
                    // 对于用户mod模型，直接使用modelInfo.path（已经包含/user_mods/路径）
                    modelJsonUrl = modelInfo.path;
                    console.log('使用用户mod模型路径:', modelJsonUrl);
                } else if (finalSteamId && finalSteamId !== 'undefined') {
                    // 如果提供了finalSteamId但没有model_config_url，使用原来的方式构建URL（兼容模式）
                    modelJsonUrl = `/workshop/${finalSteamId}/${modelName}.model3.json`;
                    console.log('兼容模式 - 构建的模型URL(带steam_id):', modelJsonUrl);
                } else {
                    // 否则使用原来的路径
                    modelJsonUrl = modelInfo.path;
                    console.log('构建的模型URL(本地):', modelJsonUrl);
                }
                const modelConfigRes = await fetch(modelJsonUrl);
                if (!modelConfigRes.ok) throw new Error((window.t && window.t('live2d.modelConfigFetchFailed', { status: modelConfigRes.statusText })) || `无法获取模型配置: ${modelConfigRes.statusText}`);
                const modelConfig = await modelConfigRes.json();

                // 3. Add URL context for the loader
                modelConfig.url = modelJsonUrl;

                // 4. Inject PreviewAll motion group AND ensure all expressions are referenced
                if (!modelConfig.FileReferences) modelConfig.FileReferences = {};

                // Motions
                if (!modelConfig.FileReferences.Motions) modelConfig.FileReferences.Motions = {};
                // 只有当模型有动作文件时才添加PreviewAll组
                if (filesData.motion_files.length > 0) {
                    modelConfig.FileReferences.Motions.PreviewAll = filesData.motion_files.map(file => ({
                        File: file  // 直接使用API返回的完整路径
                    }));
                }

                // Expressions: Overwrite with all available expression files for preview purposes.
                modelConfig.FileReferences.Expressions = filesData.expression_files.map(file => ({
                    Name: file.split('/').pop().replace('.exp3.json', ''),  // 从路径中提取文件名作为名称
                    File: file  // 直接使用API返回的完整路径
                }));

                // 5. Load preferences (如果需要)
                // const preferences = await live2dPreviewManager.loadUserPreferences();
                // const modelPreferences = preferences.find(p => p && p.model_path === modelInfo.path) || null;

                // 6. Load model FROM THE MODIFIED OBJECT
                await live2dPreviewManager.loadModel(modelConfig, {
                    loadEmotionMapping: true,
                    dragEnabled: true,
                    wheelEnabled: true
                });
                
                // 设置当前预览模型引用，用于播放动作和表情
                currentPreviewModel = live2dPreviewManager.currentModel;
                
                // 清除模型路径，防止拖动预览时自动保存到preference
                live2dPreviewManager._lastLoadedModelPath = null;
                
                // 更新预览控件
                await updatePreviewControlsAfterModelLoad(filesData);
                
                // 模型加载完成后，确保它在容器中正确显示
                setTimeout(() => {
                    if (live2dPreviewManager && live2dPreviewManager.currentModel) {
                        live2dPreviewManager.applyModelSettings(live2dPreviewManager.currentModel, {});
                        // 确保canvas正确显示，占位符被隐藏
                        document.getElementById('live2d-preview-canvas').style.display = '';
                        document.querySelector('.preview-placeholder').style.display = 'none';
                        // 强制重绘canvas
                        if (live2dPreviewManager.app && live2dPreviewManager.app.renderer) {
                            live2dPreviewManager.app.renderer.render(live2dPreviewManager.app.stage);
                        }
                    }
                }, 100);
                
                console.log('Live2D模型加载成功:', modelName);
                // 更新全局selectedModelInfo变量
                selectedModelInfo = modelInfo;
                showMessage((window.t && window.t('live2d.modelLoadSuccess', { model: modelName })) || `模型 ${modelName} 加载成功`, 'success');
            } catch (error) {
                console.error('Failed to load Live2D model by name:', error);
                showMessage((window.t && window.t('live2d.modelLoadFailed', { model: modelName })) || `加载模型 ${modelName} 失败`, 'error');
                
                // 在加载失败时隐藏预览控件
                hidePreviewControls();
            }
        }
        
        // 刷新Live2D预览
        async function refreshLive2DPreview() {
            try {
                // 检查当前是否有选中的模型
                const selectedModelName = document.getElementById('model-select').value;
                
                if (!selectedModelName) {
                    showMessage(window.t('live2d.noModelSelectedForRefresh', '请先选择一个模型进行预览'), 'warning');
                    return;
                }
                
                // 显示刷新中提示
                showMessage(window.t('live2d.refreshingPreview', '正在刷新Live2D预览...'), 'info');
                
                // 重新加载当前模型
                await loadLive2DModelByName(selectedModelName, selectedModelInfo);
                
                // 显示刷新成功提示
                showMessage(window.t('live2d.previewRefreshed', 'Live2D预览已刷新'), 'success');
            } catch (error) {
                console.error('Failed to refresh Live2D preview:', error);
                showMessage(window.t('live2d.refreshFailed', '刷新Live2D预览失败'), 'error');
            }
        }
        
        // 模型加载后更新预览控件
        async function updatePreviewControlsAfterModelLoad(filesData) {
            if (!live2dPreviewManager) {
                return;
            }
            
            // 检查filesData是否存在
            if (!filesData || !filesData.motion_files || !filesData.expression_files) {
                console.error('Invalid filesData object:', filesData);
                return;
            }
            
            // 显示Canvas，隐藏占位符
            const canvas = document.getElementById('live2d-preview-canvas');
            const placeholder = document.querySelector('.preview-placeholder');
            if (canvas) canvas.style.display = '';
            if (placeholder) placeholder.style.display = 'none';
            
            // 启用预览控件
            const motionSelect = document.getElementById('preview-motion-select');
            const expressionSelect = document.getElementById('preview-expression-select');
            const playMotionBtn = document.getElementById('preview-play-motion-btn');
            const playExpressionBtn = document.getElementById('preview-play-expression-btn');
            
            if (motionSelect) motionSelect.disabled = false;
            if (expressionSelect) expressionSelect.disabled = false;
            if (playMotionBtn) playMotionBtn.disabled = false;
            if (playExpressionBtn) playExpressionBtn.disabled = false;
            
            // 显示预览控件区域
            const previewControls = document.getElementById('live2d-preview-controls');
            if (previewControls) {
                previewControls.style.display = 'block';
            }
            
            // 更新动作和表情列表
            try {
                updatePreviewControls(filesData.motion_files, filesData.expression_files);
            } catch (error) {
                console.error('Failed to update preview controls:', error);
            }
        }
        
        // 更新动作选择器
        function updateActionSelect(motion_files) {
            // 这个函数已经被updatePreviewControls替代，保留用于向后兼容
            const motionSelect = document.getElementById('preview-motion-select');
            if (!motionSelect) return;
            
            motionSelect.innerHTML = '<option value="">' + window.t('live2d.selectAction', '选择动作') + '</option>';
            
            if (!motion_files || !Array.isArray(motion_files)) {
                return;
            }
            
            // 只有当模型有动作文件时才添加选项
            if (motion_files.length > 0) {
                motion_files.forEach(file => {
                    const option = document.createElement('option');
                    option.value = file;
                    // 从路径中提取文件名作为显示名称，移除路径和.motion3.json扩展名
                     let displayName = file.split('/').pop().replace('.motion3.json', '');
                    option.textContent = displayName;
                    motionSelect.appendChild(option);
                });
                motionSelect.disabled = false;
            } else {
                // 如果没有动作文件，添加提示选项
                const option = document.createElement('option');
                option.value = '';
                option.textContent = window.t('live2d.noMotionFiles', '没有动作文件');
                option.disabled = true;
                motionSelect.appendChild(option);
                motionSelect.disabled = true;
            }
        }
        
        // 更新表情选择器
        function updateExpressionSelect(expression_files) {
            // 这个函数已经被updatePreviewControls替代，保留用于向后兼容
            const expressionSelect = document.getElementById('preview-expression-select');
            if (!expressionSelect) return;
            
            expressionSelect.innerHTML = '<option value="">' + window.t('live2d.selectExpression', '选择表情') + '</option>';
            
            if (!expression_files || !Array.isArray(expression_files)) {
                return;
            }
            
            // 只有当模型有表情文件时才添加选项
            if (expression_files.length > 0) {
                expression_files.forEach(file => {
                    const option = document.createElement('option');
                    option.value = file;
                    // 从路径中提取文件名作为显示名称，移除路径和.exp3.json扩展名
                    let displayName = file.split('/').pop().replace('.exp3.json', '');
                    option.textContent = displayName;
                    expressionSelect.appendChild(option);
                });
                expressionSelect.disabled = false;
            } else {
                // 如果没有表情文件，添加提示选项
                const option = document.createElement('option');
                option.value = '';
                option.textContent = window.t('live2d.noExpressionFiles', '没有表情文件');
                option.disabled = true;
                expressionSelect.appendChild(option);
                expressionSelect.disabled = true;
            }
        }
        
        // 清空角色卡表单
        function clearCharacterCardForm(skipConfirm = false) {
            const clearAction = function() {
                document.getElementById('character-card-name').value = '';
                // 创建新角色卡时允许编辑名称
                document.getElementById('character-card-name').readOnly = false;
                // 隐藏编辑模式标识
                document.getElementById('edit-mode-lock').style.display = 'none';
                // 重置编辑模式状态
                currentEditCardId = null;
                currentCharacterCardId = null;
                currentEditCardOriginalName = null;
                document.getElementById('character-card-gender').value = '未知';
                document.getElementById('character-card-age').value = '';
                document.getElementById('character-card-description').value = '';
                document.getElementById('character-card-setting').value = '';
                document.getElementById('notes-input').value = '';
                document.getElementById('notes-counter').textContent = '0/30';
                clearSelectedModel();
                clearTags('character-card');
                updateCardPreview();
                updateTagsPreview();
                showMessage('表单已清空', 'info');
                
                // 滚动到角色卡编辑区域
                const characterCardInputs = document.querySelector('.character-card-inputs');
                const characterCardLayout = document.getElementById('character-card-layout');
                const scrollTarget = characterCardInputs || characterCardLayout;
                
                if (scrollTarget) {
                    scrollTarget.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            };
            
            if (skipConfirm) {
                clearAction();
            } else {
                showConfirmModal(
                    '确定要清空当前角色卡表单吗？此操作不可撤销。',
                    clearAction
                );
            }
        }
        
        // 更新角色卡信息预览
        function updateCardPreview() {
            const name = document.getElementById('character-card-name').value;
            const gender = document.getElementById('character-card-gender').value;
            const age = document.getElementById('character-card-age').value;
            const description = document.getElementById('character-card-description').value;
            const setting = document.getElementById('character-card-setting').value;
            const voice = document.getElementById('voice-select').value;
            
            const previewName = document.getElementById('preview-card-name');
            const previewGender = document.getElementById('preview-card-gender');
            const previewAge = document.getElementById('preview-card-age');
            const previewDescription = document.getElementById('preview-card-description');
            const previewSetting = document.getElementById('preview-card-setting');
            const previewVoice = document.getElementById('preview-card-voice');
            
            // 找到每个预览项中的文本元素并更新内容
            const nameText = previewName.querySelector('span');
            const genderText = previewGender.querySelector('span');
            const ageText = previewAge.querySelector('span');
            const descriptionText = previewDescription.querySelector('span');
            const settingText = previewSetting.querySelector('span');
            const voiceText = previewVoice.querySelector('span');
            
            if (nameText) nameText.textContent = name || '-';
            if (genderText) genderText.textContent = gender || '-';
            if (ageText) ageText.textContent = age || '-';
            if (descriptionText) descriptionText.textContent = description || '-';
            if (settingText) settingText.textContent = setting || '-';
            if (voiceText) voiceText.textContent = voice || '-';
        }
        
        // 更新标签预览
        function updateTagsPreview() {
            const originalTags = document.querySelectorAll('#character-card-tags-container .tag');
            const previewContainer = document.getElementById('preview-tags-container');
            
            // 清空预览容器
            previewContainer.innerHTML = '';
            
            // 复制标签到预览容器
            originalTags.forEach(tag => {
                const newTag = document.createElement('span');
                newTag.className = 'tag';
                newTag.textContent = tag.textContent.replace('×', '');
                previewContainer.appendChild(newTag);
            });
        }
        
        // 更新注意事项标签预览
        window.updateNotesPreview = function() {
            const notesInput = document.getElementById('notes-input');
            const previewContainer = document.getElementById('preview-notes-container');
            
            // 确保预览容器存在
            if (!previewContainer) return;
            
            // 清空预览容器
            previewContainer.innerHTML = '';
            
            // 从文本输入框获取注意事项内容
            if (notesInput && notesInput.value.trim()) {
                const newNote = document.createElement('span');
                newNote.className = 'tag';
                newNote.textContent = notesInput.value.trim();
                previewContainer.appendChild(newNote);
            }
        }
        
        // 为输入字段添加事件监听器，自动更新预览
        document.addEventListener('DOMContentLoaded', function() {
            const nameInput = document.getElementById('character-card-name');
            const genderInput = document.getElementById('character-card-gender');
            const ageInput = document.getElementById('character-card-age');
            const descriptionInput = document.getElementById('character-card-description');
            const settingInput = document.getElementById('character-card-setting');
            const voiceSelect = document.getElementById('voice-select');
            
            // 页面加载完成后自动加载音色列表
            loadVoices();
            
            if (nameInput) {
                nameInput.addEventListener('input', updateCardPreview);
            }
            
            if (genderInput) {
                genderInput.addEventListener('input', updateCardPreview);
            }
            
            if (ageInput) {
                ageInput.addEventListener('input', updateCardPreview);
            }
            
            if (descriptionInput) {
                descriptionInput.addEventListener('input', updateCardPreview);
            }
            
            if (settingInput) {
                settingInput.addEventListener('input', updateCardPreview);
            }
            
            if (voiceSelect) {
                voiceSelect.addEventListener('change', function() {
                    updateCardPreview();
                    
                    // 处理Voice标签
                    const voiceValue = this.value;
                    const tagsContainer = document.getElementById('character-card-tags-container');
                    const voiceTags = tagsContainer.querySelectorAll('.tag');
                    let hasVoiceTag = false;
                    
                    // 检查是否已经有Voice标签
                    Array.from(voiceTags).forEach(tag => {
                        const tagText = tag.textContent.replace('×', '').trim();
                        if (tagText === 'Voice' || tagText === '语音') {
                            hasVoiceTag = true;
                        }
                    });
                    
                    // 如果选择了音色且没有Voice标签，添加标签
                    if (voiceValue && !hasVoiceTag) {
                        addCharacterCardTag('character-card', 'Voice');
                    }
                    // 如果取消了音色选择且有Voice标签，移除标签
                    else if (!voiceValue && hasVoiceTag) {
                        const voiceTag = Array.from(voiceTags).find(tag => {
                            const tagText = tag.textContent.replace('×', '').trim();
                            return tagText === 'Voice' || tagText === '语音';
                        });
                        if (voiceTag) {
                            removeTag(voiceTag.querySelector('.tag-remove'), 'character-card');
                        }
                    }
                });
            }
            
    
        });
            
        
        
        // 清除选中的模型
        function clearSelectedModel() {
            const modelSelect = document.getElementById('model-select');
            
            // 重置下拉列表选择
            modelSelect.selectedIndex = 0;
            
            // 清除Live2D预览
            if (currentPreviewModel) {
                if (live2dPreviewManager && live2dPreviewManager.unloadCurrentModel) {
                    live2dPreviewManager.unloadCurrentModel();
                }
                currentPreviewModel = null;
            }
            
            // 隐藏Canvas，显示占位符
            document.getElementById('live2d-preview-canvas').style.display = 'none';
            document.querySelector('.preview-placeholder').style.display = 'flex';
        }
        
        // 添加标签（角色卡用）
        function addCharacterCardTag(type, tagValue) {
            console.log('addCharacterCardTag被调用:', type, tagValue);
            const tagInput = document.getElementById(`${type}-tag-input`);
            const tagText = tagValue.trim();
            
            if (tagText) {
                const tagsContainer = document.getElementById(`${type}-tags-container`);
                
                // 检查标签数量是否超过限制（最多4个）
                const existingTags = tagsContainer.querySelectorAll('.tag');
                if (existingTags.length >= 4) {
                    alert('标签数量不能超过4个！');
                    return;
                }
                
                // 检查标签字数是否超过限制（最多30字）
                if (tagText.length > 30) {
                    alert('标签字数不能超过30字！');
                    return;
                }
                
                // 检查标签是否已存在
                const tagTexts = Array.from(existingTags).map(tag => 
                    tag.textContent.replace('×', '').trim()
                );
                if (!tagTexts.includes(tagText)) {
                    // 创建新标签
                    const tagElement = document.createElement('div');
                    tagElement.className = 'tag';
                    tagElement.innerHTML = `${tagText}<span class="tag-remove" onclick="removeTag(this, '${type}')">×</span>`;
                    tagsContainer.appendChild(tagElement);
                    
                    // 更新标签预览
                    if (type === 'character-card') {
                        updateTagsPreview();
                    }
                }
            }
        }
        
        // 处理角色卡标签输入框变化
        document.addEventListener('DOMContentLoaded', function() {
            const characterTagInput = document.getElementById('character-card-tag-input');
            
            if (characterTagInput) {
                console.log('角色卡标签输入框已找到并绑定事件');
                characterTagInput.addEventListener('input', function() {
                    console.log('角色卡标签输入框输入事件触发:', this.value);
                    const inputValue = this.value;
                    
                    // 当输入空格时添加标签
                    if (inputValue.endsWith(' ')) {
                        console.log('检测到空格，准备添加标签');
                        const tagValue = inputValue.trim();
                        addCharacterCardTag('character-card', tagValue);
                        this.value = '';
                    }
                });
            } else {
                console.error('未找到角色卡标签输入框');
            }
            
            // 处理注意事项字数统计
            const notesInput = document.getElementById('notes-input');
            const notesCounter = document.getElementById('notes-counter');
            
            if (notesInput && notesCounter) {
                notesInput.addEventListener('input', function() {
                    const length = this.value.length;
                    notesCounter.textContent = `${length}/30`;
                    
                    // 超过限制时显示警告
                    if (length > 30) {
                        notesCounter.style.color = '#e74c3c';
                    } else {
                        notesCounter.style.color = '#666';
                    }
                    
                    // 实时更新预览
                    updateNotesPreview();
                });
            }
        });
        
        // 移除标签
        function removeTag(tagElement, type) {
            tagElement.parentElement.remove();
            
            // 更新标签预览
            if (type === 'character-card') {
                updateTagsPreview();
            }
        }
        
        // 清除所有标签
        function clearTags(type) {
            const tagsContainer = document.getElementById(`${type}-tags-container`);
            tagsContainer.innerHTML = '';
            
            // 更新标签预览
            if (type === 'character-card') {
                updateTagsPreview();
            }
        }
        
        // Live2D预览相关功能
        let live2dPreviewManager = null;
        let currentPreviewModel = null;
        
        // 初始化Live2D预览环境
        async function initLive2DPreview() {
            try {
                // 检查Live2DManager是否已定义
                if (typeof Live2DManager === 'undefined') {
                    throw new Error('Live2DManager class not found');
                }
                
                // 避免重复初始化
                if (live2dPreviewManager && live2dPreviewManager.currentModel) {
                    return; // 已经有模型加载，不需要重新初始化
                }
                
                // 创建一个新的Live2DManager实例
                live2dPreviewManager = new Live2DManager();
                await live2dPreviewManager.initPIXI('live2d-preview-canvas', 'live2d-preview-content');
                
                // 覆盖applyModelSettings方法，为预览模式实现专门的显示逻辑
                const originalApplyModelSettings = live2dPreviewManager.applyModelSettings;
                live2dPreviewManager.applyModelSettings = function(model, options) {
                    // 获取预览容器的尺寸
                    const container = document.getElementById('live2d-preview-content');
                    if (!container) {
                        return originalApplyModelSettings(model, options);
                    }
                    
                    const containerWidth = container.clientWidth;
                    const containerHeight = container.clientHeight;
                    
                    // 对于预览模式，我们总是使用适合容器的缩放，忽略保存的偏好设置
                    // 计算适合预览区域的缩放值，减小最大缩放值以确保模型完全显示
                    const defaultScale = Math.min(
                        0.25,  // 减小最大缩放值，使模型整体更小
                        (containerHeight * 0.85) / 7000,  // 根据容器高度计算缩放，使用更合理的比例
                        (containerWidth * 0.85) / 7000    // 根据容器宽度计算缩放，使用更合理的比例
                    );
                    
                    model.scale.set(defaultScale);
                    
                    // 设置模型位置，使其居中显示在预览区域，向下调整y轴位置
                    model.x = containerWidth * 0.5;
                    model.y = containerHeight * 0.78;  // 增加y轴位置，使模型向下移动
                    
                    // 设置锚点，确保模型完全显示
                    model.anchor.set(0.5, 0.8);  // 调整锚点，使模型顶部不会超出预览区域
                };
                
                // 添加窗口大小变化的监听，当预览区域大小变化时重新计算模型缩放和位置
                function resizePreviewModel() {
                    if (live2dPreviewManager && live2dPreviewManager.currentModel) {
                        // 调用我们覆盖的applyModelSettings方法，重新计算模型缩放和位置
                        live2dPreviewManager.applyModelSettings(live2dPreviewManager.currentModel, {});
                    }
                }
                
                // 添加removeModel方法的fallback，防止调用时出错
                if (!live2dPreviewManager.removeModel) {
                    live2dPreviewManager.removeModel = async function(force) {
                        try {
                            if (this.currentModel && this.app && this.app.stage) {
                                // 移除当前模型
                                this.app.stage.removeChild(this.currentModel);
                                this.currentModel = null;
                                
                                // 如果有清理资源的方法，调用它
                                if (this.disposeCurrentModel) {
                                    await this.disposeCurrentModel();
                                }
                            }
                        } catch (error) {
                            console.error('Error removing model:', error);
                        }
                    };
                }
                
                // 添加窗口大小变化监听
                window.addEventListener('resize', resizePreviewModel);
                
                console.log('Live2D preview environment initialized');
            } catch (error) {
                console.error('Failed to initialize Live2D preview:', error);
                showMessage(window.t('steam.live2dInitFailed'), 'error');
            }
        }
        
        // 从文件夹加载Live2D模型
        async function loadLive2DModelFromFolder(files) {
            try {
                if (!live2dPreviewManager) {
                    await initLive2DPreview();
                }
                
                // 获取第一个文件夹的名称
                const firstFolder = files[0].webkitRelativePath.split('/')[0];
                
                // 查找模型配置文件
                const modelConfigFile = files.find(file => 
                    file.name.toLowerCase().endsWith('.model3.json') && 
                    file.webkitRelativePath.startsWith(firstFolder + '/')
                );
                
                if (!modelConfigFile) {
                    throw new Error(window.t('steam.modelConfigNotFound', '模型配置文件未找到'));
                }
                
                // 读取模型配置文件内容
                const modelConfigContent = await modelConfigFile.text();
                const modelConfig = JSON.parse(modelConfigContent);
                
                // 创建一个临时的模型加载环境
                const modelFiles = {};
                
                // 收集所有模型相关文件
                const motionFiles = [];
                const expressionFiles = [];
                
                for (const file of files) {
                    if (file.webkitRelativePath.startsWith(firstFolder + '/')) {
                        const relativePath = file.webkitRelativePath.substring(firstFolder.length + 1);
                        modelFiles[relativePath] = file;
                        
                        // 收集动作文件
                        if (file.name.toLowerCase().endsWith('.motion3.json')) {
                            motionFiles.push(relativePath);
                        }
                        // 收集表情文件
                        if (file.name.toLowerCase().endsWith('.exp3.json')) {
                            expressionFiles.push(relativePath);
                        }
                    }
                }
                
                // 添加PreviewAll动作组到模型配置
                if (!modelConfig.FileReferences) modelConfig.FileReferences = {};
                if (!modelConfig.FileReferences.Motions) modelConfig.FileReferences.Motions = {};
                
                if (motionFiles.length > 0) {
                    modelConfig.FileReferences.Motions.PreviewAll = motionFiles.map(file => ({
                        File: file
                    }));
                }
                
                // 更新表情引用
                if (expressionFiles.length > 0) {
                    modelConfig.FileReferences.Expressions = expressionFiles.map(file => ({
                        Name: file.split('/').pop().replace('.exp3.json', ''),
                        File: file
                    }));
                }
                
                // 加载模型 - 禁用所有交互功能
                currentPreviewModel = await live2dPreviewManager.loadModelFromFiles(modelConfig, modelFiles, {
                    onProgress: (progress) => {
                        console.log('Model loading progress:', progress);
                    },
                    dragEnabled: false,
                    wheelEnabled: false,
                    touchZoomEnabled: false,
                    mouseTracking: false
                });
                
                // 显示Canvas，隐藏占位符
                document.getElementById('live2d-preview-canvas').style.display = '';
                document.querySelector('.preview-placeholder').style.display = 'none';
                
                // 更新预览控件
                updatePreviewControls(motionFiles, expressionFiles);
                
                // 禁用所有交互功能
                live2dPreviewManager.setLocked(true, { updateFloatingButtons: false });
                // 直接禁用canvas的pointerEvents，确保点击拖动无效
                const previewCanvas = document.getElementById('live2d-preview-canvas');
                if (previewCanvas) {
                    previewCanvas.style.pointerEvents = 'none';
                }
                
                // 确保覆盖层处于激活状态，阻挡所有鼠标事件
                const previewOverlay = document.getElementById('live2d-preview-overlay');
                if (previewOverlay) {
                    previewOverlay.style.pointerEvents = 'auto';
                }
                
                console.log('Live2D model loaded successfully');
                showMessage(window.t('steam.live2dPreviewLoaded'), 'success');
                
            } catch (error) {
                console.error('Failed to load Live2D model:', error);
                showMessage(window.t('steam.live2dPreviewLoadFailed', {error: error.message}), 'error');
                
                // 在加载失败时隐藏预览控件
                hidePreviewControls();
            }
        }
        
        // 隐藏预览控件
        function hidePreviewControls() {
            // 隐藏预览控件
            const previewControls = document.getElementById('live2d-preview-controls');
            if (previewControls) {
                previewControls.style.display = 'none';
            }
            
            // 显示占位符
            document.querySelector('.preview-placeholder').style.display = '';
            
            // 清空并禁用动作和表情选择器
            const motionSelect = document.getElementById('preview-motion-select');
            const expressionSelect = document.getElementById('preview-expression-select');
            const playMotionBtn = document.getElementById('preview-play-motion-btn');
            const playExpressionBtn = document.getElementById('preview-play-expression-btn');
            
            if (motionSelect) {
                motionSelect.innerHTML = '<option value="">' + window.t('live2d.pleaseLoadModel', '请先加载模型') + '</option>';
                motionSelect.disabled = true;
            }
            
            if (expressionSelect) {
                expressionSelect.innerHTML = '<option value="">' + window.t('live2d.pleaseLoadModel', '请先加载模型') + '</option>';
                expressionSelect.disabled = true;
            }
            
            if (playMotionBtn) {
                playMotionBtn.disabled = true;
            }
            
            if (playExpressionBtn) {
                playExpressionBtn.disabled = true;
            }
        }
        
        // 重置预览控件
        function resetPreviewControls() {
            const motionSelect = document.getElementById('preview-motion-select');
            const expressionSelect = document.getElementById('preview-expression-select');
            const playMotionBtn = document.getElementById('preview-play-motion-btn');
            const playExpressionBtn = document.getElementById('preview-play-expression-btn');
            const previewControls = document.getElementById('live2d-preview-controls');
            
            // 重置选择框
            if (motionSelect) {
                motionSelect.innerHTML = `<option value="">${window.t('live2d.selectMotion', '选择动作')}</option>`;
                motionSelect.disabled = true;
            }
            
            if (expressionSelect) {
                expressionSelect.innerHTML = `<option value="">${window.t('live2d.selectExpression', '选择表情')}</option>`;
                expressionSelect.disabled = true;
            }
            
            // 禁用播放按钮
            if (playMotionBtn) {
                playMotionBtn.disabled = true;
            }
            
            if (playExpressionBtn) {
                playExpressionBtn.disabled = true;
            }
            
            // 隐藏预览控件
            hidePreviewControls();
        }
        
        // 更新预览控件
        function updatePreviewControls(motionFiles, expressionFiles) {
            const motionSelect = document.getElementById('preview-motion-select');
            const expressionSelect = document.getElementById('preview-expression-select');
            const playMotionBtn = document.getElementById('preview-play-motion-btn');
            const playExpressionBtn = document.getElementById('preview-play-expression-btn');
            const previewControls = document.getElementById('live2d-preview-controls');
            
            // 检查必要的DOM元素是否存在
            if (!motionSelect || !expressionSelect || !playMotionBtn || !playExpressionBtn) {
                console.error('Missing required DOM elements for preview controls');
                return;
            }
            
            // 清空现有选项
            motionSelect.innerHTML = '';
            expressionSelect.innerHTML = '';
            
            // 更新动作选择框
            if (motionFiles.length > 0) {
                motionSelect.disabled = false;
                playMotionBtn.disabled = false;
                
                // 添加动作选项
                motionFiles.forEach((motionFile, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = motionFile;
                    motionSelect.appendChild(option);
                });
            } else {
                motionSelect.disabled = true;
                playMotionBtn.disabled = true;
                
                const option = document.createElement('option');
                option.value = '';
                option.textContent = window.t('live2d.noMotionFiles', '没有动作文件');
                motionSelect.appendChild(option);
            }
            
            // 更新表情选择框
            if (expressionFiles.length > 0) {
                expressionSelect.disabled = false;
                playExpressionBtn.disabled = false;
                
                // 添加表情选项
                expressionFiles.forEach(expressionFile => {
                    const expressionName = expressionFile.split('/').pop().replace('.exp3.json', '');
                    const option = document.createElement('option');
                    option.value = expressionName;
                    option.textContent = expressionName;
                    expressionSelect.appendChild(option);
                });
            } else {
                expressionSelect.disabled = true;
                playExpressionBtn.disabled = true;
                
                const option = document.createElement('option');
                option.value = '';
                option.textContent = window.t('live2d.noExpressionFiles', '没有表情文件');
                expressionSelect.appendChild(option);
            }
            
            // 显示预览控件
            previewControls.style.display = '';
        }
        
        // 播放预览动作
        const playMotionBtn = document.getElementById('preview-play-motion-btn');
        if (playMotionBtn) {
            playMotionBtn.addEventListener('click', () => {
                if (!currentPreviewModel) return;
                
                const motionSelect = document.getElementById('preview-motion-select');
                const motionIndex = parseInt(motionSelect.value);
                
                if (isNaN(motionIndex)) return;
                
                try {
                    currentPreviewModel.motion('PreviewAll', motionIndex, 3);
                    console.log('Playing motion:', motionIndex);
                } catch (error) {
                    console.error('Failed to play motion:', error);
                    showMessage(window.t('live2d.playMotionFailed', {motion: motionIndex}), 'error');
                }
            });
        }
        
        // 播放预览表情
        const playExpressionBtn = document.getElementById('preview-play-expression-btn');
        if (playExpressionBtn) {
            playExpressionBtn.addEventListener('click', () => {
                if (!currentPreviewModel) return;
                
                const expressionSelect = document.getElementById('preview-expression-select');
                const expressionName = expressionSelect.value;
                
                if (!expressionName) return;
                
                try {
                    currentPreviewModel.expression(expressionName);
                    console.log('Playing expression:', expressionName);
                } catch (error) {
                    console.error('Failed to play expression:', error);
                    showMessage(window.t('live2d.playExpressionFailed', {expression: expressionName}), 'error');
                }
            });
        }
        
        // 页面加载完成后初始化Live2D预览环境
        document.addEventListener('DOMContentLoaded', function() {
            // 延迟初始化，确保其他资源已加载
            setTimeout(initLive2DPreview, 1000);
        });
        
        // 注意事项标签功能
        (function() {
            const tagsContainer = document.getElementById('notes-tags-container');
            const notesInput = document.getElementById('workshop-notes-input');
            let notesTags = [];
            
            // 渲染标签
            function renderTags() {
                tagsContainer.innerHTML = '';
                notesTags.forEach((tag, index) => {
                    const tagElement = document.createElement('span');
                    tagElement.className = 'tag';
                    tagElement.innerHTML = `
                        <span>${tag}</span>
                        <button class="tag-remove" onclick="removeNotesTag(${index})" title="删除标签">
                            <span>×</span>
                        </button>
                    `;
                    tagsContainer.appendChild(tagElement);
                });
                updateNotesPreview(); // 更新预览，移到循环外部确保无论是否有标签都会执行
            }
            
            // 添加标签
            function addNotesTag(tagValue) {
                if (tagValue && tagValue.trim()) {
                    const tag = tagValue.trim();
                    
                    // 检查标签数量是否超过限制（最多4个）
                    if (notesTags.length >= 4) {
                        alert('标签数量不能超过4个！');
                        return;
                    }
                    
                    // 检查标签字数是否超过限制（最多30字）
                    if (tag.length > 30) {
                        alert('标签字数不能超过30字！');
                        return;
                    }
                    
                    // 去重
                    if (!notesTags.includes(tag)) {
                        notesTags.push(tag);
                        renderTags();
                    }
                }
            }
            
            // 删除标签
            window.removeNotesTag = function(index) {
                notesTags.splice(index, 1);
                renderTags();
            }
            
            // 处理输入框变化
            function handleInput() {
                const inputValue = notesInput.value;
                
                // 当输入空格时添加标签
                if (inputValue.endsWith(' ')) {
                    const tagValue = inputValue.trim();
                    addNotesTag(tagValue);
                    notesInput.value = '';
                }
            }
            
            // 监听输入变化，按空格添加标签
            if (notesInput) {
                notesInput.addEventListener('input', handleInput);
            }
            
            // 导出addNotesTag函数供外部使用
        window.addNotesTag = addNotesTag;
    })();
    
    // 预览图片选择功能
    function selectPreviewImage() {
        // 创建文件选择事件监听
        const fileInput = document.getElementById('preview-image-file');
        
        // 清除之前的事件监听
        fileInput.onchange = null;
        
        // 添加新的事件监听
        fileInput.onchange = function(e) {
            if (e.target.files && e.target.files[0]) {
                const file = e.target.files[0];
                
                // 创建FormData对象，用于上传文件
                const formData = new FormData();
                // 获取原始文件扩展名
                const fileExtension = file.name.split('.').pop().toLowerCase();
                // 创建新的File对象，使用统一的文件名"preview.扩展名"
                const renamedFile = new File([file], `preview.${fileExtension}`, { 
                    type: file.type, 
                    lastModified: file.lastModified 
                });
                formData.append('file', renamedFile);
                
                // 获取内容文件夹路径（如果已选择）
                const contentFolder = document.getElementById('content-folder').value.trim();
                if (contentFolder) {
                    formData.append('content_folder', contentFolder);
                }
                
                // 显示上传进度
                showMessage(window.t ? window.t('steam.uploadingPreviewImage') : '正在上传预览图片...', 'info');
                
                // 上传文件到服务器
                fetch('/api/steam/workshop/upload-preview-image', {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // 设置服务器返回的临时文件路径
                        document.getElementById('preview-image').value = data.file_path;
                        console.log("Uploaded preview image path:", data.file_path);
                        showMessage(window.t ? window.t('steam.previewImageUploaded') : '预览图片上传成功', 'success');
                    } else {
                        console.error("上传预览图片失败:", data.message);
                        showMessage(window.t ? window.t('steam.previewImageUploadFailed', {error: data.message}) : `预览图片上传失败: ${data.message}`, 'error');
                    }
                })
                .catch(error => {
                    console.error("上传预览图片出错:", error);
                    showMessage(window.t ? window.t('steam.previewImageUploadError', {error: error.message}) : `预览图片上传出错: ${error.message}`, 'error');
                });
            }
        };
        
        // 触发文件选择对话框
        fileInput.click();
    }
    </script>
        
    <!-- Live2D核心库和依赖 -->
    <script src="/static/libs/pixi.min.js"></script>
    <script src="/static/libs/live2dcubismcore.min.js"></script>
    <script src="/static/libs/live2d.min.js"></script>
    <script src="/static/libs/index.min.js"></script>
    
    <!-- Live2D功能模块 -->
    <script src="/static/live2d-core.js"></script>
    <script src="/static/live2d-model.js"></script>
    <script src="/static/live2d-interaction.js"></script>
    <script src="/static/live2d-emotion.js"></script>
    <script src="/static/live2d-ui-buttons.js"></script>
    <script src="/static/live2d-init.js"></script>
    
    <script>
        // 打开模型目录函数
        function openModelDirectory() {
            const modelSelect = document.getElementById('model-select');
            const selectedModelName = modelSelect.value;
            
            if (!selectedModelName) {
                showMessage(window.t ? window.t('steam.noModelSelected') : '请先选择一个模型', 'warning');
                return;
            }
            
            // 调用后端API打开目录
            fetch(`/api/live2d/open_model_directory/${encodeURIComponent(selectedModelName)}`)
                .then(response => response.json())
                .then(data => {
                    if (!data.success) {
                        showMessage(data.error || (window.t ? window.t('steam.openDirectoryFailed') : '打开目录失败'), 'error');
                    }
                })
                .catch(error => {
                    console.error('打开目录失败:', error);
                    showMessage(window.t ? window.t('steam.openDirectoryFailed') : '打开目录失败', 'error');
                });
        }
    </script>
</body>

</html>